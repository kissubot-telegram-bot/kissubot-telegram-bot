// // bot.js
// require('dotenv').config();
// process.env.NODE_ENV = process.env.NODE_ENV || 'development';
// const TelegramBot = require('node-telegram-bot-api');
// const axios = require('axios');
// const http = require('http');

// // Configure axios with timeout and retry logic
// axios.defaults.timeout = 10000; // 10 second timeout
// axios.defaults.headers.common['Connection'] = 'keep-alive';
// const express = require('express');
// const bodyParser = require('body-parser');
// const mongoose = require('mongoose');

// // MongoDB connection with retry logic
// const connectWithRetry = async () => {
//   const maxRetries = 5;
//   let retries = 0;

//   while (retries < maxRetries) {
//     try {
//       await mongoose.connect(process.env.MONGODB_URI, {
//         useNewUrlParser: true,
//         useUnifiedTopology: true,
//         serverSelectionTimeoutMS: 5000, // Timeout after 5s instead of 30s
//         socketTimeoutMS: 45000, // Close sockets after 45s of inactivity
//       });
//       console.log('MongoDB connected successfully');
//       break;
//     } catch (err) {
//       retries += 1;
//       console.error(`MongoDB connection attempt ${retries} failed:`, err.message);
//       if (retries === maxRetries) {
//         console.error('Max retries reached. Could not connect to MongoDB');
//         process.exit(1);
//       }
//       // Wait before retrying (exponential backoff)
//       await new Promise(resolve => setTimeout(resolve, Math.pow(2, retries) * 1000));
//     }
//   }
// };

// // Handle MongoDB connection errors
// mongoose.connection.on('error', err => {
//   console.error('MongoDB connection error:', err);
// });

// mongoose.connection.on('disconnected', () => {
//   console.log('MongoDB disconnected. Attempting to reconnect...');
//   connectWithRetry();
// });

// // Initial connection
// connectWithRetry();

// const app = express();
// app.use(bodyParser.json());
// const BOT_TOKEN = process.env.BOT_TOKEN;
// // Use localhost for development, deployed URL for production
// const API_BASE = process.env.NODE_ENV === 'production' 
//   ? 'https://kissubot-telegram-bot.onrender.com'  // Server runs on same instance in production
//   : (process.env.API_BASE || 'http://localhost:3003');
// // Bot configuration
// // Use webhook for production (Render), polling for local development
// const bot = new TelegramBot(BOT_TOKEN, {
//   webHook: false, // We'll handle webhook manually via Express
//   polling: process.env.NODE_ENV !== 'production' ? {
//     interval: 300, // Poll interval in milliseconds
//     autoStart: true, // Start polling automatically
//     params: {
//       timeout: 10 // Long polling timeout in seconds
//     }
//   } : false
// });
// console.log('BOT_TOKEN loaded:', BOT_TOKEN ? 'Yes' : 'No');

// // Verify bot connection
// bot.getMe().then((me) => {
//   console.log('Bot connected to Telegram API as:', me.username);
// }).catch((err) => {
//   console.error('Failed to connect to Telegram API:', err.message);
// });

// // Error handling for polling errors
// bot.on('polling_error', (error) => {
//   console.error('Polling error:', error);
//   // Attempt to restart polling after a delay
//   setTimeout(() => {
//     try {
//       console.log('Attempting to stop polling...');
//       bot.stopPolling();
//       console.log('Polling stopped.');
//       setTimeout(() => {
//         console.log('Attempting to start polling...');
//         bot.startPolling();
//         console.log('Polling started.');
//         console.log('Polling restarted after error');
//       }, 5000);
//     } catch (e) {
//       console.error('Failed to restart polling:', e);
//     }
//   }, 10000);
// });

// // Handle other bot errors
// bot.on('error', (error) => {
//   console.error('Bot error:', error);
// });

// // Log all incoming messages
// bot.on('message', (msg) => {
//   console.log('Received message:', msg);
// });

// // Connection status logging
// bot.on('webhook_error', (error) => {
//   console.error('Webhook error:', error);
// });

// console.log('Bot initialized and starting...');
// console.log('NODE_ENV:', process.env.NODE_ENV);
// console.log('PORT:', process.env.PORT);

// // Detect production environment
// const isProduction = process.env.NODE_ENV === 'production';

// // Webhook setup for production deployment
// const PORT = process.env.PORT || 3001;

// // Webhook endpoint for Telegram
// app.post(`/bot${BOT_TOKEN}`, (req, res) => {
//   bot.processUpdate(req.body);
//   res.sendStatus(200);
// });

// // Health check endpoint
// app.get('/', (req, res) => {
//   res.json({ 
//     status: 'Kisu1bot is running!', 
//     timestamp: new Date().toISOString(),
//     mode: process.env.NODE_ENV || 'development',
//     isProduction: isProduction,
//     webhookEndpoint: `/bot${BOT_TOKEN ? '[TOKEN_SET]' : '[TOKEN_MISSING]'}`
//   });
// });

// // Debug endpoint to check webhook status
// app.get('/webhook-info', async (req, res) => {
//   try {
//     const webhookInfo = await bot.getWebHookInfo();
//     res.json({
//       webhook: webhookInfo,
//       botToken: BOT_TOKEN ? 'SET' : 'MISSING',
//       expectedUrl: `https://kissubot-telegram-bot.onrender.com/bot${BOT_TOKEN ? '[TOKEN]' : '[MISSING]'}`
//     });
//   } catch (error) {
//     res.json({
//       error: error.message,
//       botToken: BOT_TOKEN ? 'SET' : 'MISSING'
//     });
//   }
// });

// // Set webhook URL for production
// if (isProduction) {
//   const webhookUrl = `https://kissubot-telegram-bot.onrender.com/bot${BOT_TOKEN}`;
//   bot.setWebHook(webhookUrl)
//     .then(() => {
//       console.log('Webhook set successfully:', webhookUrl.replace(BOT_TOKEN, '[TOKEN_MASKED]'));
//     })
//     .catch((error) => {
//       console.error('Failed to set webhook:', error);
//     });
// }

// const userMatchQueue = {}; // Temporary in-memory queue
// const State = require('./state');
// const userStates = {}; // Temporary user states for multi-step actions

// // Performance optimizations
// const userCache = new Map(); // Cache user profiles for 5 minutes
// const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// // Helper function to get cached user data
// async function getCachedUserProfile(telegramId) {
//   const cacheKey = `profile_${telegramId}`;
//   const cached = userCache.get(cacheKey);
  
//   if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
//     return cached.data;
//   }
  
//   try {
//     const res = await axios.get(`${API_BASE}/users/${telegramId}`);
//     userCache.set(cacheKey, {
//       data: res.data,
//       timestamp: Date.now()
//     });
//     return res.data;
//   } catch (err) {
//     return null;
//   }
// }

// // Clear cache periodically
// setInterval(() => {
//   const now = Date.now();
//   for (const [key, value] of userCache.entries()) {
//     if (now - value.timestamp > CACHE_DURATION) {
//       userCache.delete(key);
//     }
//   }
// }, CACHE_DURATION);

// async function sendPromotionalMessage(telegramId, message, options) {
//   const user = await getCachedUserProfile(telegramId);
//   if (user && user.isVip && user.vipDetails.benefits.adFree) {
//     // Don't send promotional messages to VIP users with ad-free benefit
//     return;
//   }
//   bot.sendMessage(telegramId, message, options);
// }

// function sendNextProfile(chatId, telegramId) {
//   const queue = userMatchQueue[telegramId];
//   if (!queue || queue.length === 0) {
//     return sendPromotionalMessage(chatId, 'No more profiles right now. Upgrade to VIP to see more!');
//   }

//   const user = queue.shift();
//   const text = `@${user.username || 'unknown'}\nAge: ${user.age}\nGender: ${user.gender}\nBio: ${user.bio}\nInterests: ${user.interests?.join(', ') || 'None'}`;
//   const opts = {
//     reply_markup: {
//       inline_keyboard: [[
//         { text: '‚ù§Ô∏è Like', callback_data: `like_${user.telegramId}` },
//         { text: '‚ùå Pass', callback_data: `pass` }
//       ]]
//     }
//   };

//   bot.sendMessage(chatId, text, opts);
// }

// bot.on('message', async (msg) => {
//   console.log('Received message:', JSON.stringify(msg, null, 2));
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
//   const text = msg.text;

//   if (!text) {
//     console.log('Received non-text message:', msg);
//     return;
//   }

//   try {
//     if (text.startsWith('/')) {
//       console.log(`Processing command: ${text}`);
//     }

//     if (text === '/start') {
//       sendPromotionalMessage(chatId, 'Welcome to Kisu1bot! Use /register to get started.');
//     } else if (text === '/register') {
//       try {
//         await State.findOneAndUpdate({ telegramId }, { step: 'register_name' }, { upsert: true });
//         bot.sendMessage(chatId, "Let's get you registered! What's your name?");
//       } catch (error) {
//         console.error('Error starting registration:', error);
//         bot.sendMessage(chatId, 'Sorry, something went wrong. Please try again later.');
//       }
//     } else if (text === '/purchase_coins') {
//       try {
//         const response = await axios.get(`${API_BASE}/coins/packages`);
//         const packages = response.data;

//         if (!packages || packages.length === 0) {
//           return bot.sendMessage(chatId, 'Sorry, there are no coin packages available at the moment. Please check back later.');
//         }

//         const buttons = packages.map(pkg => ([{
//           text: `${pkg.name} (${pkg.coins} coins) - $${pkg.price}`,
//           callback_data: `purchase_coins_${pkg.packageId}`
//         }]));

//         const message = 'üíé **Purchase Coins** üíé\n\n' +
//           'Top up your coin balance to unlock exclusive features and stand out from the crowd!\n\n' +
//           '**Why buy coins?**\n' +
//           '‚Ä¢ Send premium gifts üéÅ\n' +
//           '‚Ä¢ Boost your profile visibility ‚ú®\n' +
//           '‚Ä¢ Get more matches ‚ù§Ô∏è\n\n' +
//           'Choose a package below to get started:';

//         bot.sendMessage(chatId, message, {
//           reply_markup: {
//             inline_keyboard: buttons
//           }
//         });
//       } catch (error) {
//         console.error('Error fetching coin packages:', error.response ? error.response.data : error.message);
//         bot.sendMessage(chatId, 'Sorry, something went wrong while fetching coin packages. Please try again later.');
//       }
//     } else if (text === '/profile') {
//       try {
//         const user = await getCachedUserProfile(telegramId);
//         if (user) {
//           const profileMessage = `üë§ **Your Profile** üë§\n\n` +
//             `**Name:** ${user.name || 'N/A'}\n` +
//             `**Age:** ${user.age || 'N/A'}\n` +
//             `**Gender:** ${user.gender || 'N/A'}\n` +
//             `**Location:** ${user.location || 'N/A'}\n` +
//             `**Bio:** ${user.bio || 'N/A'}\n` +
//             `**Interests:** ${user.interests?.join(', ') || 'N/A'}`;
          
//           bot.sendMessage(chatId, profileMessage);
//         } else {
//           bot.sendMessage(chatId, 'Could not retrieve your profile. Have you registered with /register?');
//         }
//       } catch (error) {
//         bot.sendMessage(chatId, 'There was an error fetching your profile.');
//         console.error('[/profile] Error:', error.response ? error.response.data : error.message);
//       }
//     } else if (text === '/browse') {
//       try {
//         const res = await axios.get(`${API_BASE}/browse/${telegramId}`);
//         if (res.data && res.data.length > 0) {
//           userMatchQueue[telegramId] = res.data;
//           sendNextProfile(chatId, telegramId);
//         } else {
//           bot.sendMessage(chatId, 'No potential matches found right now. Try again later!');
//         }
//       } catch (error) {
//         bot.sendMessage(chatId, 'There was an error while browsing. Please try again.');
//         console.error('[/browse] Error:', error.response ? error.response.data : error.message);
//       }
//     } else if (text === '/help') {
//       const helpMsg = `ü§ñ **KISU1BOT HELP GUIDE** ü§ñ\n\n` +
//         `üìã **Main Commands:**\n` +
//         `‚Ä¢ /start - Welcome message\n` +
//         `‚Ä¢ /register - Create your dating profile\n` +
//         `‚Ä¢ /browse - Browse and like profiles\n` +
//         `‚Ä¢ /profile - View/edit your profile\n` +
//         `‚Ä¢ /settings - Access all settings\n\n` +
//         `üí¨ **Social Features:**\n` +
//         `‚Ä¢ /stories - Post and view stories\n` +
//         `‚Ä¢ /gifts - Send gifts to matches\n` +
//         `‚Ä¢ /matches - View your matches\n\n` +
//         `üíé **Premium Features:**\n` +
//         `‚Ä¢ /coins - Buy coins for premium features\n` +
//         `‚Ä¢ /vip - Get VIP membership benefits\n\n` +
//         `üõ†Ô∏è **Support Commands:**\n` +
//         `‚Ä¢ /help - Show this help guide\n` +
//         `‚Ä¢ /report - Report users or issues\n` +
//         `‚Ä¢ /contact - Contact support team\n` +
//         `‚Ä¢ /delete - Delete your profile\n\n` +
//         `üí° **Tips:**\n` +
//         `‚Ä¢ Complete your profile for better matches\n` +
//         `‚Ä¢ Be respectful and genuine\n` +
//         `‚Ä¢ Use stories to show your personality\n` +
//         `‚Ä¢ VIP membership unlocks premium features`;

//       const buttons = [
//         [
//           { text: 'üë§ My Profile', callback_data: 'view_profile' },
//           { text: 'üîç Browse Profiles', callback_data: 'browse_profiles' }
//         ],
//         [
//           { text: '‚öôÔ∏è Settings', callback_data: 'main_settings' },
//           { text: 'üíé Get VIP', callback_data: 'manage_vip' }
//         ],
//         [
//           { text: 'üìû Contact Support', callback_data: 'contact_support' }
//         ]
//       ];

//       bot.sendMessage(chatId, helpMsg, {
//         reply_markup: {
//           inline_keyboard: buttons
//         }
//       });
//     } else if (text === '/report') {
//       const reportMsg = `üö® **REPORT CENTER** üö®\n\n` +
//         `Help us keep Kisu1bot safe for everyone!\n\n` +
//         `üìù **What can you report?**\n` +
//         `‚Ä¢ Inappropriate behavior\n` +
//         `‚Ä¢ Fake profiles\n` +
//         `‚Ä¢ Spam or harassment\n` +
//         `‚Ä¢ Technical issues\n` +
//         `‚Ä¢ Other violations\n\n` +
//         `‚ö†Ô∏è **Before reporting:**\n` +
//         `‚Ä¢ Make sure you have valid reasons\n` +
//         `‚Ä¢ False reports may result in penalties\n` +
//         `‚Ä¢ Provide as much detail as possible`;

//       const buttons = [
//         [
//           { text: 'üë§ Report User', callback_data: 'report_user' },
//           { text: 'üêõ Report Bug', callback_data: 'report_bug' }
//         ],
//         [
//           { text: 'üí¨ Report Inappropriate Content', callback_data: 'report_content' }
//         ],
//         [
//           { text: 'üìû Contact Support Instead', callback_data: 'contact_support' }
//         ]
//       ];

//       bot.sendMessage(chatId, reportMsg, {
//         reply_markup: {
//           inline_keyboard: buttons
//         }
//       });
//     } else if (text === '/delete') {
//       const deleteMsg = `‚ö†Ô∏è **DELETE PROFILE** ‚ö†Ô∏è\n\n` +
//     `üö® **WARNING: This action cannot be undone!**\n\n` +
//     `Deleting your profile will:\n` +
//     `‚Ä¢ Remove all your profile data\n` +
//     `‚Ä¢ Delete your photos and information\n` +
//     `‚Ä¢ Remove you from all matches\n` +
//     `‚Ä¢ Cancel any active VIP subscription\n` +
//     `‚Ä¢ Clear your chat history\n\n` +
//     `üíî **Are you sure you want to continue?**\n\n` +
//     `Consider these alternatives:\n` +
//     `‚Ä¢ Take a break (deactivate temporarily)\n` +
//     `‚Ä¢ Update your preferences\n` +
//     `‚Ä¢ Contact support for help`;

//       const buttons = [
//         [
//           { text: '‚ùå Cancel - Keep My Profile', callback_data: 'cancel_delete' }
//         ],
//         [
//           { text: '‚è∏Ô∏è Deactivate Temporarily', callback_data: 'deactivate_profile' }
//         ],
//         [
//           { text: 'üóëÔ∏è DELETE PERMANENTLY', callback_data: 'confirm_delete_profile' }
//         ],
//         [
//           { text: 'üìû Contact Support First', callback_data: 'contact_support' }
//         ]
//       ];

//       bot.sendMessage(chatId, deleteMsg, {
//         reply_markup: {
//           inline_keyboard: buttons
//         }
//       });
//     } else {
//       const state = await State.findOne({ telegramId });
//       if (state && (state.step.startsWith('register_') || state.step.startsWith('edit_'))) {
//         const [action, field] = state.step.split('_');

//         if (action === 'register') {
//           // Existing registration logic
//           switch (field) {
//             case 'name':
//               await State.updateOne({ telegramId }, { 'data.name': text, step: 'register_age' });
//               bot.sendMessage(chatId, 'Great! How old are you?');
//               break;
//             case 'age':
//               await State.updateOne({ telegramId }, { 'data.age': parseInt(text, 10), step: 'register_location' });
//               bot.sendMessage(chatId, 'Where are you located?');
//               break;
//             case 'location':
//               await State.updateOne({ telegramId }, { 'data.location': text, step: 'register_bio' });
//               bot.sendMessage(chatId, 'Tell us a bit about yourself (your bio).');
//               break;
//             case 'bio':
//               const finalState = await State.findOneAndUpdate({ telegramId }, { 'data.bio': text, step: 'completed' }, { new: true });
              
//               const postData = JSON.stringify({
//                 telegramId: telegramId,
//                 username: msg.from.username,
//                 name: finalState.data.name,
//                 age: finalState.data.age,
//                 location: finalState.data.location,
//                 bio: finalState.data.bio
//               });

//               const options = {
//                 hostname: 'localhost',
//                 port: 3003,
//                 path: '/register',
//                 method: 'POST',
//                 headers: {
//                   'Content-Type': 'application/json',
//                   'Content-Length': Buffer.byteLength(postData)
//                 }
//               };

//               const req = http.request(options, (res) => {
//                 let data = '';
//                 res.on('data', (chunk) => {
//                   data += chunk;
//                 });
//                 res.on('end', () => {
//                   if (res.statusCode === 201) {
//                     bot.sendMessage(chatId, 'You have been registered successfully!');
//                     State.deleteOne({ telegramId }).catch(err => console.error('Error deleting state:', err));
//                   } else {
//                     bot.sendMessage(chatId, 'There was an error during registration. Please try again.');
//                     console.error('Registration error:', data);
//                   }
//                 });
//               });

//               req.on('error', (e) => {
//                 bot.sendMessage(chatId, 'There was an error during registration. Please try again.');
//                 console.error(`Problem with request: ${e.message}`);
//               });

//               req.write(postData);
//               req.end();
//               break;
//           }
//         } else if (action === 'edit') {
//           try {
//             await axios.put(`${API_BASE}/profile/${telegramId}`, { [field]: text });
//             bot.sendMessage(chatId, `‚úÖ Your ${field} has been updated!`);
//             await State.deleteOne({ telegramId });
//           } catch (error) {
//             bot.sendMessage(chatId, `‚ùå Failed to update your ${field}. Please try again.`);
//             console.error(`Error updating ${field}:`, error.response ? error.response.data : error.message);
//           }
//         }
//       }
//     }
//   } catch (error) {
//     console.error('Error processing message:', error);
//     bot.sendMessage(chatId, 'An unexpected error occurred. Please try again.');
//   }
// });



// // Contact support command
// bot.onText(/\/contact/, (msg) => {
//   const chatId = msg.chat.id;
//   const contactMsg = `üìû **CONTACT SUPPORT** üìû\n\n` +
//     `Our support team is here to help!\n\n` +
//     `üïê **Support Hours:**\n` +
//     `Monday - Friday: 9 AM - 6 PM UTC\n` +
//     `Weekend: Limited support\n\n` +
//     `üìß **Contact Methods:**\n` +
//     `‚Ä¢ Email: spprtksbt@gmail.com\n` +
//     `‚Ä¢ Response time: 24-48 hours\n\n` +
//     `üí¨ **Common Issues:**\n` +
//     `‚Ä¢ Profile not showing up\n` +
//     `‚Ä¢ Payment/VIP problems\n` +
//     `‚Ä¢ Technical difficulties\n` +
//     `‚Ä¢ Account recovery\n` +
//     `‚Ä¢ Report violations\n\n` +
//     `üìã **Before contacting:**\n` +
//     `‚Ä¢ Check /help for common solutions\n` +
//     `‚Ä¢ Include your Telegram username\n` +
//     `‚Ä¢ Describe the issue clearly`;

//   const buttons = [
//     [
//       { text: 'üìß Email Support', callback_data: 'email_support' }
//     ],
//     [
//       { text: 'üö® Report Issue', callback_data: 'report_user' },
//       { text: '‚ùì FAQ/Help', callback_data: 'show_help' }
//     ],
//     [
//       { text: 'üí¨ Send Feedback', callback_data: 'send_feedback' }
//     ]
//   ];

//   bot.sendMessage(chatId, contactMsg, {
//     reply_markup: {
//       inline_keyboard: buttons
//     }
//   });
// });

// // Settings command
// bot.onText(/\/settings/, (msg) => {
//   const chatId = msg.chat.id;
//   const settingsMsg = `‚öôÔ∏è **SETTINGS MENU** ‚öôÔ∏è\n\n` +
//     `Customize your Kisu1bot experience!\n\n` +
//     `üë§ **Profile Settings**\n` +
//     `‚Ä¢ Edit your profile information\n` +
//     `‚Ä¢ Update photos and bio\n` +
//     `‚Ä¢ Privacy preferences\n\n` +
//     `üîç **Search Preferences**\n` +
//     `‚Ä¢ Age range and distance\n` +
//     `‚Ä¢ Gender preferences\n` +
//     `‚Ä¢ Location settings\n\n` +
//     `üíé **Premium Features**\n` +
//     `‚Ä¢ VIP membership\n` +
//     `‚Ä¢ Coins and purchases\n` +
//     `‚Ä¢ Priority features\n\n` +
//     `üîî **Notifications**\n` +
//     `‚Ä¢ Match notifications\n` +
//     `‚Ä¢ Message alerts\n` +
//     `‚Ä¢ Activity updates`;

//   const buttons = [
//     [
//       { text: 'üë§ Profile Settings', callback_data: 'settings_profile' },
//       { text: 'üîç Search Preferences', callback_data: 'settings_search' }
//     ],
//     [
//       { text: 'üíé Premium Features', callback_data: 'settings_premium' },
//       { text: 'üîî Notifications', callback_data: 'settings_notifications' }
//     ],
//     [
//       { text: 'üîí Privacy & Safety', callback_data: 'settings_privacy' },
//       { text: 'üõ†Ô∏è Account Settings', callback_data: 'settings_account' }
//     ],
//     [
//       { text: '‚ùì Help & Support', callback_data: 'settings_help' }
//     ]
//   ];

//   bot.sendMessage(chatId, settingsMsg, {
//     reply_markup: {
//       inline_keyboard: buttons
//     }
//   });
// });

// // Removed duplicate /start handler that was incorrectly auto-registering users

// // REGISTER command
// bot.onText(/\/register/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     // Check if user is already registered
//     try {
//       const existingUser = await getCachedUserProfile(telegramId);
//       if (existingUser) {
//         return bot.sendMessage(
//           chatId,
//           '‚úÖ You\'re already registered!\n\n' +
//           'You can:\n' +
//           '‚Ä¢ Use /profile to view your profile\n' +
//           '‚Ä¢ Use /browse to find people\n' +
//           '‚Ä¢ Use /matches to see your matches'
//         );
//       }
//     } catch (err) {
//       // User not found, continue with registration
//       if (err.response?.status !== 404) {
//         throw err;
//       }
//     }

//     // Register the user
//     const res = await axios.post(`${API_BASE}/register`, {
//       telegramId,
//       username: msg.from.username || '',
//       name: msg.from.first_name || '',
//     });

//     // Send welcome message with next steps
//     const welcomeMsg = 
//       'üéâ Registration successful!\n\n' +
//       'Let\'s set up your profile:\n' +
//       '1Ô∏è‚É£ Use /setname to set your display name\n' +
//       '2Ô∏è‚É£ Use /setage to set your age\n' +
//       '3Ô∏è‚É£ Use /setlocation to set your location\n' +
//       '4Ô∏è‚É£ Use /setbio to write about yourself\n\n' +
//       'After setting up your profile, you can:\n' +
//       '‚Ä¢ Use /browse to find people\n' +
//       '‚Ä¢ Use /matches to see your matches';

//     bot.sendMessage(chatId, welcomeMsg);
//   } catch (err) {
//     console.error('[/register] Error:', err.response?.data || err.message);
//     bot.sendMessage(
//       chatId,
//       '‚ùå Registration failed. Please try again later.\n' +
//       'If the problem persists, contact support.'
//     );
//   }
// });

// // BROWSE command
// bot.onText(/\/browse/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     const res = await axios.get(`${API_BASE}/browse/${telegramId}`);
//     const profile = res.data;

//     if (!profile) {
//       return bot.sendMessage(
//         chatId,
//         'üîç No more profiles to show right now.\n\n' +
//         'Try again later or adjust your search settings with /search'
//       );
//     }

//     const profileText = `üë§ ${profile.name || 'Anonymous'}, ${profile.age || '?'}\n` +
//       `üìç ${profile.location || 'Location not set'}\n\n` +
//       `${profile.bio || 'No bio available'}`;

//     const opts = {
//       reply_markup: {
//         inline_keyboard: [
//           [
//             { text: '‚ù§Ô∏è Like', callback_data: `like_${profile.telegramId}` },
//             { text: 'üëé Pass', callback_data: `pass_${profile.telegramId}` }
//           ],
//           [
//             { text: 'üéÅ Send Gift', callback_data: `gift_${profile.telegramId}` },
//             { text: '‚≠ê Super Like', callback_data: `superlike_${profile.telegramId}` }
//           ]
//         ]
//       }
//     };

//     if (profile.photoUrl) {
//       bot.sendPhoto(chatId, profile.photoUrl, {
//         caption: profileText,
//         reply_markup: opts.reply_markup
//       });
//     } else {
//       bot.sendMessage(chatId, profileText, opts);
//     }

//   } catch (err) {
//     console.error('[/browse] Error:', err.response?.data || err.message);
//     bot.sendMessage(chatId, '‚ùå Failed to load profiles. Please try again later.');
//   }
// });


// // MATCHES
// bot.onText(/\/matches/, async (msg) => {
//   const chatId = msg.chat.id;
//   // Placeholder for matched users
//   bot.sendMessage(chatId, `üíû You have no matches yet.
// Keep browsing and liking profiles!`);
// });

// // Global message handler to process profile edits
// bot.on('message', async (msg) => {
//   try {
//     const chatId = msg.chat.id;
//     const telegramId = msg.from?.id;
//     if (!telegramId) return;

//     const state = userStates[telegramId];
//     if (!state) return; // not in any flow

//     const text = (msg.text || '').trim();
//     if (!text) return;

//     // Handle cancel
//     if (text.toLowerCase() === '/cancel') {
//       delete userStates[telegramId];
//       if (state.editing) {
//         await bot.sendMessage(chatId, '‚ùå Edit cancelled.');
//       } else if (state.reporting) {
//         await bot.sendMessage(chatId, '‚ùå Report cancelled. Thank you for helping keep our community safe!');
//       } else if (state.uploadingPhoto) {
//         await bot.sendMessage(chatId, '‚ùå Photo upload cancelled.');
//       }
//       return;
//     }

//     // Handle report submissions
//     if (state.reporting) {
//       const reportType = state.reporting; // 'user' | 'content' | 'bug' | 'feature'
      
//       if (text.length < 10) {
//         return bot.sendMessage(chatId, '‚ùå Please provide more details (at least 10 characters). Send a more detailed report or /cancel to abort.');
//       }

//       // Process the report
//       const reportData = {
//         type: reportType,
//         reporterId: telegramId,
//         description: text,
//         timestamp: new Date().toISOString()
//       };

//       // Log the report (in a real app, you'd save this to database)
//       console.log('Report received:', reportData);

//       delete userStates[telegramId];

//       const reportTypeLabels = {
//         user: 'User Report',
//         content: 'Content Report', 
//         bug: 'Bug Report',
//         feature: 'Feature Request'
//       };

//       await bot.sendMessage(chatId, `‚úÖ **${reportTypeLabels[reportType]} Submitted** ‚úÖ\n\n` +
//         `Thank you for your report! Our team will review it and take appropriate action.\n\n` +
//         `üìß You may receive a follow-up email if we need more information.\n\n` +
//         `üõ°Ô∏è Your report helps keep Kisu1bot safe for everyone!`, {
//         reply_markup: {
//           inline_keyboard: [[
//             { text: 'üìû Contact Support', callback_data: 'contact_support' },
//             { text: 'üîô Back to Help', callback_data: 'show_help' }
//           ]]
//         }
//       });
//       return;
//     }

//     // Handle profile edits
//     if (!state.editing) return; // not in edit flow
//     const field = state.editing; // 'name' | 'age' | 'location' | 'bio'
//     let value = text;

//     // Validate input
//     if (field === 'name') {
//       if (value.length < 2 || value.length > 50) {
//         return bot.sendMessage(chatId, '‚ùå Name must be between 2 and 50 characters. Try again or send /cancel.');
//       }
//     } else if (field === 'age') {
//       const n = parseInt(value, 10);
//       if (isNaN(n) || n < 18 || n > 99) {
//         return bot.sendMessage(chatId, '‚ùå Please send a valid age between 18 and 99.');
//       }
//       value = n;
//     } else if (field === 'location') {
//       if (value.length < 2 || value.length > 100) {
//         return bot.sendMessage(chatId, '‚ùå Location must be between 2 and 100 characters. Try again or send /cancel.');
//       }
//     } else if (field === 'bio') {
//       if (value.length > 300) {
//         return bot.sendMessage(chatId, `‚ùå Bio is too long (${value.length} chars). Max is 300. Please shorten and resend.`);
//       }
//     }

//     // Commit update to backend
//     try {
//       const res = await axios.post(`${API_BASE}/profile/update/${telegramId}`, { field, value });
//       delete userStates[telegramId];

//       const labelMap = { name: 'Name', age: 'Age', location: 'Location', bio: 'Bio' };
//       await bot.sendMessage(chatId, `‚úÖ ${labelMap[field]} updated successfully!`, {
//         reply_markup: {
//           inline_keyboard: [[
//             { text: 'üîô Back to Profile Settings', callback_data: 'settings_profile' }
//           ]]
//         }
//       });
//     } catch (err) {
//       console.error('Profile update error:', err.response?.data || err.message);
//       await bot.sendMessage(chatId, '‚ùå Failed to update your profile. Please try again later.');
//     }
//   } catch (e) {
//     console.error('Message handler error:', e);
//   }
// });

// bot.on('callback_query', async (query) => {
//   const chatId = query.message.chat.id;
//   const telegramId = query.from.id;
//   const data = query.data;

//   if (data.startsWith('like_')) {
//     const toId = data.split('_')[1];
//     try {
//       const res = await axios.post(`${API_BASE}/like`, {
//         fromId: telegramId,
//         toId,
//       });

//       if (res.data.matched) {
//         bot.sendMessage(chatId, `You matched with @${res.data.username || 'someone'}!`);
//       } else {
//         bot.sendMessage(chatId, res.data.message || 'Liked!');
//       }
//     } catch (err) {
//       bot.sendMessage(chatId, 'Error while liking.');
//     }
//   } else {
//     switch(data) {
//       case 'edit_profile':
//         case 'settings_profile':
//           try {
//             const profileRes = await axios.get(`${API_BASE}/profile/${telegramId}`);
//             const user = profileRes.data;
  
//             const profileMsg = `üë§ **PROFILE SETTINGS** üë§\n\n` +
//               `üìù **Current Information:**\n` +
//               `‚Ä¢ Name: ${user.name || 'Not set'}\n` +
//               `‚Ä¢ Age: ${user.age || 'Not set'}\n` +
//               `‚Ä¢ Location: ${user.location || 'Not set'}\n` +
//               `‚Ä¢ Bio: ${user.bio || 'Not set'}\n\n` +
//               `‚úèÔ∏è **What would you like to edit?**`;
  
//             const buttons = [
//               [
//                 { text: 'üìù Edit Name', callback_data: 'edit_name' },
//                 { text: 'üéÇ Edit Age', callback_data: 'edit_age' }
//               ],
//               [
//                 { text: 'üìç Edit Location', callback_data: 'edit_location' },
//                 { text: 'üí≠ Edit Bio', callback_data: 'edit_bio' }
//               ],
//               [
//                 { text: 'üì∏ Manage Photos', callback_data: 'manage_photos' }
//               ],
//               [
//                 { text: 'üîô Back to Settings', callback_data: 'main_settings' }
//               ]
//             ];
  
//             bot.sendMessage(chatId, profileMsg, {
//               reply_markup: {
//                 inline_keyboard: buttons
//               }
//             });
//           } catch (err) {
//             bot.sendMessage(chatId, '‚ùå Failed to load your profile. Please try /register first.');
//           }
//           break;
  
//         case 'edit_name':
//           userStates[telegramId] = { editing: 'name' };
//           bot.sendMessage(chatId, 'üìù **Edit Name**\n\nPlease enter your new name:');
//           break;
  
//         case 'edit_age':
//           userStates[telegramId] = { editing: 'age' };
//           bot.sendMessage(chatId, 'üéÇ **Edit Age**\n\nPlease enter your age (18-99):');
//           break;
  
//         case 'edit_bio':
//           userStates[telegramId] = { editing: 'bio' };
//           bot.sendMessage(chatId, 'üí≠ **Edit Bio**\n\nPlease enter your bio (max 500 characters):');
//           break;

//       case 'view_stories':
//         try {
//           const storiesRes = await axios.get(`${API_BASE}/stories/recent/${telegramId}`);
//           const stories = storiesRes.data.stories || [];
          
//           if (stories.length === 0) {
//             return bot.sendMessage(chatId, 
//               'üì∏ **NO NEW STORIES** üì∏\n\n' +
//               'üòî No new stories to view right now.\n\n' +
//               'üí° **Tips:**\n' +
//               '‚Ä¢ Follow more people to see their stories\n' +
//               '‚Ä¢ Post your own story to get more followers\n' +
//               '‚Ä¢ Use /browse to find interesting people'
//             );
//           }

//           // Show stories viewer
//           const viewMsg = `üëÄ **VIEWING STORIES** üëÄ\n\n` +
//             `üì± Found **${stories.length}** new stories\n\n` +
//             `Tap to view each story:`;

//           const storyButtons = stories.slice(0, 6).map((story, index) => [
//             { text: `üì∏ ${story.userName} ${story.isVip ? 'üëë' : ''}`, callback_data: `view_story_${story._id}` }
//           ]);

//           storyButtons.push([
//             { text: 'üîô Back to Stories', callback_data: 'stories_main_menu' }
//           ]);

//           bot.editMessageText(viewMsg, {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: { inline_keyboard: storyButtons },
//             parse_mode: 'Markdown'
//           });
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Unable to load stories. Please try again.');
//         }
//         break;

//       case 'post_story':
//         // Set user state to expect story content
//         userStates[telegramId] = { awaitingStory: true };
        
//         const postMsg = `üì∏ **POST YOUR STORY** üì∏\n\n` +
//           `üì± Send me a photo or video for your story!\n\n` +
//           `‚ú® **Story Features:**\n` +
//           `‚Ä¢ Visible for 24 hours\n` +
//           `‚Ä¢ Add text caption\n` +
//           `‚Ä¢ See who viewed it\n` +
//           `‚Ä¢ Boost your profile visibility\n\n` +
//           `üì∑ Just send your photo/video now!`;

//         bot.editMessageText(postMsg, {
//           chat_id: chatId,
//           message_id: query.message.message_id,
//           reply_markup: {
//             inline_keyboard: [
//               [{ text: '‚ùå Cancel', callback_data: 'stories_main_menu' }]
//             ]
//           },
//           parse_mode: 'Markdown'
//         });
//         break;

//       case 'my_stories':
//         try {
//           const userStoriesRes = await axios.get(`${API_BASE}/stories/user/${telegramId}`);
//           const userStories = userStoriesRes.data.stories || [];
          
//           if (userStories.length === 0) {
//             const noStoriesMsg = `üì± **YOUR STORIES** üì±\n\n` +
//               `üì∏ You haven't posted any stories yet.\n\n` +
//               `üí° **Why post stories?**\n` +
//               `‚Ä¢ Get more profile views\n` +
//               `‚Ä¢ Show your personality\n` +
//               `‚Ä¢ Connect with more people\n` +
//               `‚Ä¢ Increase your matches\n\n` +
//               `Ready to share your first story?`;

//             bot.editMessageText(noStoriesMsg, {
//               chat_id: chatId,
//               message_id: query.message.message_id,
//               reply_markup: {
//                 inline_keyboard: [
//                   [{ text: 'üì∏ Post First Story', callback_data: 'post_story' }],
//                   [{ text: 'üîô Back to Stories', callback_data: 'stories_main_menu' }]
//                 ]
//               },
//               parse_mode: 'Markdown'
//             });
//           } else {
//             const storiesMsg = `üì± **YOUR STORIES** üì±\n\n` +
//               `üì∏ Active Stories: **${userStories.length}**\n\n` +
//               userStories.slice(0, 5).map((story, index) => {
//                 const timeAgo = Math.floor((Date.now() - new Date(story.createdAt)) / (1000 * 60 * 60));
//                 const views = story.views ? story.views.length : 0;
//                 return `${index + 1}. ${story.type === 'photo' ? 'üì∑' : 'üé•'} Posted ${timeAgo}h ago\n` +
//                        `   üëÄ ${views} views`;
//               }).join('\n\n');

//             const myStoriesButtons = [
//               [
//                 { text: 'üì∏ Post New Story', callback_data: 'post_story' },
//                 { text: 'üëÄ View Analytics', callback_data: 'story_stats' }
//               ],
//               [{ text: 'üîô Back to Stories', callback_data: 'stories_main_menu' }]
//             ];

//             bot.editMessageText(storiesMsg, {
//               chat_id: chatId,
//               message_id: query.message.message_id,
//               reply_markup: { inline_keyboard: myStoriesButtons },
//               parse_mode: 'Markdown'
//             });
//           }
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Unable to load your stories. Please try again.');
//         }
//         break;

//       case 'story_stats':
//         try {
//           const [userStoriesRes, analyticsRes] = await Promise.all([
//             axios.get(`${API_BASE}/stories/user/${telegramId}`),
//             axios.get(`${API_BASE}/stories/analytics/${telegramId}`)
//           ]);
          
//           const stories = userStoriesRes.data.stories || [];
//           const analytics = analyticsRes.data || {};
          
//           const statsMsg = `üìä **STORY ANALYTICS** üìä\n\n` +
//             `üì∏ **Your Stories:**\n` +
//             `   Total Posted: **${analytics.totalStories || 0}**\n` +
//             `   Currently Active: **${stories.length}**\n\n` +
//             `üëÄ **Views & Engagement:**\n` +
//             `   Total Views: **${analytics.totalViews || 0}**\n` +
//             `   Average Views: **${analytics.avgViews || 0}**\n` +
//             `   Profile Visits: **${analytics.profileVisits || 0}**\n\n` +
//             `üî• **Performance:**\n` +
//             `   Best Story: **${analytics.bestStoryViews || 0}** views\n` +
//             `   Engagement Rate: **${analytics.engagementRate || 0}%**\n\n` +
//             `üí° Post more stories to boost your visibility!`;

//           bot.editMessageText(statsMsg, {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   { text: 'üì∏ Post Story', callback_data: 'post_story' },
//                   { text: 'üì± My Stories', callback_data: 'my_stories' }
//                 ],
//                 [{ text: 'üîô Back to Stories', callback_data: 'stories_main_menu' }]
//               ]
//             },
//             parse_mode: 'Markdown'
//           });
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Unable to load story analytics. Please try again.');
//         }
//         break;

//       case 'story_settings':
//         const settingsMsg = `‚öôÔ∏è **STORY SETTINGS** ‚öôÔ∏è\n\n` +
//           `üîí **Privacy Settings:**\n` +
//           `‚Ä¢ Who can view your stories\n` +
//           `‚Ä¢ Story visibility duration\n` +
//           `‚Ä¢ Auto-delete settings\n\n` +
//           `üì± **Notification Settings:**\n` +
//           `‚Ä¢ New story alerts\n` +
//           `‚Ä¢ View notifications\n` +
//           `‚Ä¢ Story interaction alerts`;

//         bot.editMessageText(settingsMsg, {
//           chat_id: chatId,
//           message_id: query.message.message_id,
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üîí Privacy Settings', callback_data: 'story_privacy' },
//                 { text: 'üîî Notifications', callback_data: 'story_notifications' }
//               ],
//               [{ text: 'üîô Back to Stories', callback_data: 'stories_main_menu' }]
//             ]
//           },
//           parse_mode: 'Markdown'
//         });
//         break;

//       case 'story_help':
//         const helpMsg = `‚ùì **STORY HELP GUIDE** ‚ùì\n\n` +
//           `üì∏ **What are Stories?**\n` +
//           `Stories are photos/videos that disappear after 24 hours. They're perfect for sharing moments and connecting with others!\n\n` +
//           `üéØ **How to Use Stories:**\n` +
//           `1. Tap "üì∏ Post Story"\n` +
//           `2. Send a photo or video\n` +
//           `3. Add a caption (optional)\n` +
//           `4. Your story goes live!\n\n` +
//           `‚ú® **Story Benefits:**\n` +
//           `‚Ä¢ Increase profile visibility\n` +
//           `‚Ä¢ Show your personality\n` +
//           `‚Ä¢ Get more matches\n` +
//           `‚Ä¢ See who's interested in you\n\n` +
//           `üí° **Pro Tips:**\n` +
//           `‚Ä¢ Post regularly for best results\n` +
//           `‚Ä¢ Use good lighting for photos\n` +
//           `‚Ä¢ Add engaging captions\n` +
//           `‚Ä¢ Check your story analytics`;

//         bot.editMessageText(helpMsg, {
//           chat_id: chatId,
//           message_id: query.message.message_id,
//           reply_markup: {
//             inline_keyboard: [
//               [{ text: 'üì∏ Post Your First Story', callback_data: 'post_story' }],
//               [{ text: 'üîô Back to Stories', callback_data: 'stories_main_menu' }]
//             ]
//           },
//           parse_mode: 'Markdown'
//         });
//         break;

//       case 'stories_main_menu':
//         // Return to main stories menu
//         try {
//           const [userStoriesRes, recentStoriesRes] = await Promise.all([
//             axios.get(`${API_BASE}/stories/user/${telegramId}`).catch(() => ({ data: { stories: [] } })),
//             axios.get(`${API_BASE}/stories/recent/${telegramId}`).catch(() => ({ data: { stories: [] } }))
//           ]);

//           const userStories = userStoriesRes.data.stories || [];
//           const recentStories = recentStoriesRes.data.stories || [];

//           const mainMenuMsg = `üì∏ **STORIES CENTER** üì∏\n\n` +
//             `üì± Your Stories: **${userStories.length}** active\n` +
//             `üëÄ New Stories: **${recentStories.length}** to view\n\n` +
//             `üéØ What would you like to do?`;

//           bot.editMessageText(mainMenuMsg, {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   { text: 'üì∏ Post Story', callback_data: 'post_story' },
//                   { text: 'üëÄ View Stories', callback_data: 'view_stories' }
//                 ],
//                 [
//                   { text: 'üì± My Stories', callback_data: 'my_stories' },
//                   { text: 'üìä Story Stats', callback_data: 'story_stats' }
//                 ],
//                 [
//                   { text: '‚öôÔ∏è Story Settings', callback_data: 'story_settings' },
//                   { text: '‚ùì Story Help', callback_data: 'story_help' }
//                 ]
//               ]
//             },
//             parse_mode: 'Markdown'
//           });
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Unable to load stories menu. Please try again.');
//         }
//         break;

//       case 'buy_coins':
//         try {
//           const res = await axios.get(`${API_BASE}/coins/${telegramId}`);
//           const { coins, packages } = res.data;

//           const balanceMsg = `üí∞ Your Coin Balance: ${coins} ü™ô\n\n` +
//             'üéÅ Available Packages:';

//           const packageButtons = Object.entries(packages).map(([id, pack]) => ({
//             text: `${pack.name} (${pack.coins + pack.bonus} coins)`,
//             callback_data: `buy_coins_${id}`
//           }));

//           const buttonRows = packageButtons.reduce((rows, button, index) => {
//             if (index % 2 === 0) {
//               rows.push([button]);
//             } else {
//               rows[rows.length - 1].push(button);
//             }
//             return rows;
//           }, []);

//           const packagesMsg = Object.values(packages).map(pack => 
//             `\n\n${pack.name}:` +
//             `\n‚Ä¢ ${pack.coins} coins` +
//             (pack.bonus ? `\n‚Ä¢ +${pack.bonus} bonus coins` : '') +
//             `\n‚Ä¢ $${pack.price}`
//           ).join('');

//           const opts = {
//             reply_markup: {
//               inline_keyboard: buttonRows
//             }
//           };

//           bot.sendMessage(
//             chatId,
//             balanceMsg + packagesMsg + '\n\nüí° Coins can be used for VIP membership, gifts, and other premium features!',
//             opts
//           );
//         } catch (err) {
//           bot.sendMessage(chatId, 'Failed to fetch coin balance.');
//         }
//         break;

//       case 'extend_vip':
//         bot.sendMessage(chatId, 'Choose a plan to extend your VIP membership:', {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üìÖ Monthly', callback_data: 'vip_purchase_monthly' },
//                 { text: 'üìÜ Yearly', callback_data: 'vip_purchase_yearly' }
//               ],
//               [{ text: '‚ôæÔ∏è Lifetime', callback_data: 'vip_purchase_lifetime' }]
//             ]
//           }
//         });
//         break;

//       case 'cancel_vip':
//         try {
//           await axios.post(`${API_BASE}/vip/cancel/${telegramId}`);
//           bot.sendMessage(chatId, 'Your VIP subscription has been cancelled. You will retain benefits until the current period ends.');
//         } catch (err) {
//           bot.sendMessage(chatId, 'Failed to cancel VIP subscription.');
//         }
//         break;

//       case 'vip_purchase_monthly':
//       case 'vip_purchase_yearly':
//       case 'vip_purchase_lifetime':
//         const planType = data.split('_')[2]; // monthly, yearly, or lifetime
//         try {
//           const res = await axios.post(`${API_BASE}/vip/purchase/${telegramId}`, {
//             planType
//           });
          
//           const successMessage = `üéâ Congratulations! Your ${planType} VIP subscription is now active!\n\n` +
//             `Remaining coins: ${res.data.remainingCoins} ü™ô\n` +
//             'Use /vip to see your benefits and status.';
          
//           bot.sendMessage(chatId, successMessage);
//         } catch (err) {
//           if (err.response?.data?.error === 'Insufficient coins') {
//             const required = err.response.data.required;
//             const current = err.response.data.current;
//             bot.sendMessage(chatId, 
//               `You need ${required} coins for this plan, but you only have ${current} coins.\n` +
//               'Use /coins to purchase more coins!'
//             );
//           } else {
//             bot.sendMessage(chatId, 'Failed to purchase VIP subscription. Please try again later.');
//           }
//         }
//         break;
//       case data.match(/^priority_(.+)$/)?.input:
//         const priorityPlan = data.split('_')[1];
//         try {
//           const res = await axios.post(`${API_BASE}/priority/purchase/${telegramId}`, {
//             planType: priorityPlan
//           });
          
//           const expiryDate = new Date(res.data.expiresAt).toLocaleString();
//           const successMsg = '‚ö°Ô∏è Priority Status Activated!\n\n' +
//             `Your profile will be shown first until ${expiryDate}\n` +
//             `Remaining coins: ${res.data.remainingCoins} ü™ô`;
          
//           bot.sendMessage(chatId, successMsg);
//         } catch (err) {
//           if (err.response?.data?.error === 'Insufficient coins') {
//             const required = err.response.data.required;
//             const current = err.response.data.current;
//             bot.sendMessage(chatId, 
//               `You need ${required} coins for this plan, but you only have ${current} coins.\n` +
//               'Use /coins to get more coins!'
//             );
//           } else {
//             bot.sendMessage(chatId, 'Failed to activate priority status. Please try again later.');
//           }
//         }
//         break;

//       case 'chat_(.+)'?.input:
//         const chatUserId = data.split('_')[1];
//         bot.sendMessage(chatId, 'Opening chat... (Chat feature coming soon)');
//         break;

//       case 'unmatch_(.+)'?.input:
//         const unmatchUserId = data.split('_')[1];
//         try {
//           await axios.post(`${API_BASE}/matches/unmatch`, {
//             fromId: telegramId,
//             toId: unmatchUserId
//           });
//           bot.sendMessage(chatId, 'Successfully unmatched. Use /browse to find new matches!');
//         } catch (err) {
//           bot.sendMessage(chatId, 'Failed to unmatch. Please try again later.');
//         }
//         break;

//       case 'pass_like_(.+)'?.input:
//         const passUserId = data.split('_')[2];
//         try {
//           // Remove the like from the database
//           await axios.post(`${API_BASE}/likes/remove`, {
//             fromId: passUserId,
//             toId: telegramId
//           });
//           bot.sendMessage(chatId, 'Profile passed. Use /likesyou to see your remaining likes!');
//         } catch (err) {
//           bot.sendMessage(chatId, 'Failed to pass profile. Please try again later.');
//         }
//         break;

//       case 'view_story_(.+)'?.input:
//         const storyId = data.split('_')[2];
//         try {
//           const response = await axios.post(`${API_BASE}/stories/view/${storyId}`, {
//             viewerId: telegramId
//           });
          
//           const story = response.data.story;
//           const viewCount = response.data.viewCount;
          
//           // Send the story media with caption
//           const storyCaption = `üì∏ **${story.ownerName}** ${story.ownerIsVip ? 'üëë' : ''}\n\n` +
//             (story.caption ? `"${story.caption}"\n\n` : '') +
//             `üëÄ ${viewCount} views ‚Ä¢ ${Math.floor((Date.now() - new Date(story.createdAt)) / (1000 * 60 * 60))}h ago`;
          
//           if (story.type === 'photo') {
//             await bot.sendPhoto(chatId, story.mediaUrl, {
//               caption: storyCaption,
//               parse_mode: 'Markdown',
//               reply_markup: {
//                 inline_keyboard: [
//                   [
//                     { text: 'üë§ View Profile', callback_data: `view_profile_${story.userId}` },
//                     { text: '‚ù§Ô∏è Like', callback_data: `like_${story.userId}` }
//                   ],
//                   [
//                     { text: 'üîô Back to Stories', callback_data: 'view_stories' }
//                   ]
//                 ]
//               }
//             });
//           } else if (story.type === 'video') {
//             await bot.sendVideo(chatId, story.mediaUrl, {
//               caption: storyCaption,
//               parse_mode: 'Markdown',
//               reply_markup: {
//                 inline_keyboard: [
//                   [
//                     { text: 'üë§ View Profile', callback_data: `view_profile_${story.userId}` },
//                     { text: '‚ù§Ô∏è Like', callback_data: `like_${story.userId}` }
//                   ],
//                   [
//                     { text: 'üîô Back to Stories', callback_data: 'view_stories' }
//                   ]
//                 ]
//               }
//             });
//           }
//         } catch (err) {
//           if (err.response?.status === 410) {
//             bot.sendMessage(chatId, '‚è∞ This story has expired and is no longer available.');
//           } else {
//             console.error('Error viewing story:', err);
//             bot.sendMessage(chatId, '‚ùå Unable to load this story. Please try again.');
//           }
//         }
//         break;
//       // Handle coin package purchases
//       case 'buy_coins_starter':
//       case 'buy_coins_popular':
//       case 'buy_coins_premium':
//       case 'buy_coins_ultimate':
//         const packageId = data.split('_')[2];
//         try {
//           const res = await axios.post(`${API_BASE}/coins/purchase/${telegramId}`, {
//             packageId
//           });
          
//           const { coinsAdded, newBalance } = res.data;
          
//           // Get package details for confirmation message
//           const packageDetails = {
//             starter: { name: 'Starter Pack', coins: 1000, bonus: 0, price: 4.99 },
//             popular: { name: 'Popular Pack', coins: 5000, bonus: 500, price: 19.99 },
//             premium: { name: 'Premium Pack', coins: 12000, bonus: 2000, price: 39.99 },
//             ultimate: { name: 'Ultimate Pack', coins: 30000, bonus: 8000, price: 79.99 }
//           };
          
//           const pack = packageDetails[packageId];
//           const successMsg = `üéâ **PURCHASE SUCCESSFUL!** üéâ\n\n` +
//             `üì¶ **${pack.name}** purchased!\n` +
//             `üí∞ **${coinsAdded} coins** added to your account\n` +
//             `ü™ô **New Balance:** ${newBalance} coins\n\n` +
//             `‚ú® **What you can do with coins:**\n` +
//             `‚Ä¢ üëë Purchase VIP membership\n` +
//             `‚Ä¢ üéÅ Send premium gifts\n` +
//             `‚Ä¢ ‚ö°Ô∏è Boost your profile priority\n` +
//             `‚Ä¢ üåü Unlock special features\n\n` +
//             `Thank you for your purchase! üíô`;
          
//           await bot.sendMessage(chatId, successMsg, {
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   { text: 'üëë Get VIP', callback_data: 'manage_vip' },
//                   { text: 'üéÅ Send Gifts', callback_data: 'send_gift' }
//                 ],
//                 [
//                   { text: '‚ö°Ô∏è Priority Boost', callback_data: 'priority_boost' },
//                   { text: 'üí∞ Buy More Coins', callback_data: 'buy_coins' }
//                 ]
//               ]
//             },
//             parse_mode: 'Markdown'
//           });
          
//         } catch (err) {
//           console.error('Coin purchase error:', err);
//           if (err.response?.status === 400) {
//             bot.sendMessage(chatId, '‚ùå Invalid package selected. Please try again.');
//           } else if (err.response?.status === 404) {
//             bot.sendMessage(chatId, '‚ùå User not found. Please register first using /start.');
//           } else {
//             bot.sendMessage(chatId, '‚ùå Failed to purchase coins. Please try again later.');
//           }
//         }
//         break;

//       case 'extend_vip':
//         bot.sendMessage(chatId, 'Choose a plan to extend your VIP membership:', {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üìÖ Monthly', callback_data: 'vip_purchase_monthly' },
//                 { text: 'üìÜ Yearly', callback_data: 'vip_purchase_yearly' }
//               ],
//               [{ text: '‚ôæÔ∏è Lifetime', callback_data: 'vip_purchase_lifetime' }]
//             ]
//           }
//         });
//         break;

//       // Search Settings callbacks
//       case 'set_age_range':
//         bot.sendMessage(chatId, 'üë• **SET AGE RANGE** üë•\n\nChoose your preferred age range for matches:', {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: '18-25', callback_data: 'age_range_18_25' },
//                 { text: '26-35', callback_data: 'age_range_26_35' }
//               ],
//               [
//                 { text: '36-45', callback_data: 'age_range_36_45' },
//                 { text: '46-55', callback_data: 'age_range_46_55' }
//               ],
//               [
//                 { text: '18-35', callback_data: 'age_range_18_35' },
//                 { text: '25-45', callback_data: 'age_range_25_45' }
//               ],
//               [
//                 { text: 'üîô Back to Settings', callback_data: 'back_to_search' }
//               ]
//             ]
//           },
//           parse_mode: 'Markdown'
//         });
//         break;

//       case 'set_distance':
//         bot.sendMessage(chatId, 'üìç **SET DISTANCE** üìç\n\nChoose maximum distance for matches:', {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: '10 km', callback_data: 'distance_10' },
//                 { text: '25 km', callback_data: 'distance_25' }
//               ],
//               [
//                 { text: '50 km', callback_data: 'distance_50' },
//                 { text: '100 km', callback_data: 'distance_100' }
//               ],
//               [
//                 { text: '250 km', callback_data: 'distance_250' },
//                 { text: 'Unlimited', callback_data: 'distance_unlimited' }
//               ],
//               [
//                 { text: 'üîô Back to Settings', callback_data: 'back_to_search' }
//               ]
//             ]
//           },
//           parse_mode: 'Markdown'
//         });
//         break;

//       case 'set_gender_pref':
//         bot.sendMessage(chatId, '‚ößÔ∏è **GENDER PREFERENCE** ‚ößÔ∏è\n\nWho would you like to see?', {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üë® Men', callback_data: 'gender_male' },
//                 { text: 'üë© Women', callback_data: 'gender_female' }
//               ],
//               [
//                 { text: 'üë• Everyone', callback_data: 'gender_any' }
//               ],
//               [
//                 { text: 'üîô Back to Settings', callback_data: 'back_to_search' }
//               ]
//             ]
//           },
//           parse_mode: 'Markdown'
//         });
//         break;

//             // Apply age range selections
//       case 'age_range_18_25':
//       case 'age_range_26_35':
//       case 'age_range_36_45':
//       case 'age_range_46_55':
//       case 'age_range_18_35':
//       case 'age_range_25_45': {
//         try {
//           let ageMin = 18, ageMax = 35;
//           switch (data) {
//             case 'age_range_18_25': ageMin = 18; ageMax = 25; break;
//             case 'age_range_26_35': ageMin = 26; ageMax = 35; break;
//             case 'age_range_36_45': ageMin = 36; ageMax = 45; break;
//             case 'age_range_46_55': ageMin = 46; ageMax = 55; break;
//             case 'age_range_18_35': ageMin = 18; ageMax = 35; break;
//             case 'age_range_25_45': ageMin = 25; ageMax = 45; break;
//           }
//           await axios.post(`${API_BASE}/search-settings/${telegramId}`, { ageMin, ageMax });
//           await bot.sendMessage(chatId, `‚úÖAge range updated to ${ageMin}-${ageMax} years!`, {
//             reply_markup: { inline_keyboard: [[{ text: '√∞≈∏‚Äù‚Ñ¢ Back to Search', callback_data: 'back_to_search' }]] },
//             parse_mode: 'Markdown'
//           });
//         } catch (err) {
//           console.error('Set age range error:', err.response?.data || err.message);
//           bot.sendMessage(chatId, '√¢¬ù≈í Failed to update age range. Please try again.');
//         }
//         break;
//       }

//       // Apply distance selections
//       case 'distance_10':
//       case 'distance_25':
//       case 'distance_50':
//       case 'distance_100':
//       case 'distance_250':
//       case 'distance_unlimited': {
//         try {
//           let maxDistance;
//           switch (data) {
//             case 'distance_10': maxDistance = 10; break;
//             case 'distance_25': maxDistance = 25; break;
//             case 'distance_50': maxDistance = 50; break;
//             case 'distance_100': maxDistance = 100; break;
//             case 'distance_250': maxDistance = 250; break;
//             case 'distance_unlimited': maxDistance = 100000; break;
//           }
//           await axios.post(`${API_BASE}/search-settings/${telegramId}`, { maxDistance });
//           const label = data === 'distance_unlimited' ? 'Unlimited' : `${maxDistance} km`;
//           await bot.sendMessage(chatId, `‚úÖMax distance updated to ${label}!`, {
//             reply_markup: { inline_keyboard: [[{ text: '√∞≈∏‚Äù‚Ñ¢ Back to Search', callback_data: 'back_to_search' }]] },
//             parse_mode: 'Markdown'
//           });
//         } catch (err) {
//           console.error('Set distance error:', err.response?.data || err.message);
//           bot.sendMessage(chatId, '√¢¬ù≈í Failed to update distance. Please try again.');
//         }
//         break;
//       }

//       // Apply gender preference selections
//       case 'gender_male':
//       case 'gender_female':
//       case 'gender_any': {
//         try {
//           let genderPreference;
//           if (data === 'gender_male') genderPreference = 'Male';
//           else if (data === 'gender_female') genderPreference = 'Female';
//           else genderPreference = 'Any';
//           await axios.post(`${API_BASE}/search-settings/${telegramId}`, { genderPreference });
//           await bot.sendMessage(chatId, `‚úÖGender preference set to ${genderPreference}!`, {
//             reply_markup: { inline_keyboard: [[{ text: '√∞≈∏‚Äù‚Ñ¢ Back to Search', callback_data: 'back_to_search' }]] },
//             parse_mode: 'Markdown'
//           });
//         } catch (err) {
//           console.error('Set gender preference error:', err.response?.data || err.message);
//           bot.sendMessage(chatId, '√¢¬ù≈í Failed to update gender preference. Please try again.');
//         }
//         break;
//       }case 'premium_filters':
//         bot.sendMessage(chatId, 'üíé **PREMIUM FILTERS** üíé\n\nüëë VIP members get access to:\n\n‚Ä¢ Education level filter\n‚Ä¢ Profession filter\n‚Ä¢ Interests matching\n‚Ä¢ Verified profiles only\n‚Ä¢ Recent activity filter\n\nUpgrade to VIP to unlock these features!', {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üëë Get VIP', callback_data: 'manage_vip' }
//               ],
//               [
//                 { text: 'üîô Back to Settings', callback_data: 'back_to_search' }
//               ]
//             ]
//           }
//         });
//         break;

//       case 'set_location_pref':
//         const locationMsg = `üåç **LOCATION PREFERENCES** üåç\n\n` +
//           `üìç **Choose your preferred search area:**\n\n` +
//           `‚Ä¢ Current City - Search in your current location\n` +
//           `‚Ä¢ Nearby Cities - Include surrounding areas\n` +
//           `‚Ä¢ Specific City - Choose a different city\n` +
//           `‚Ä¢ Anywhere - No location restrictions`;

//         bot.editMessageText(locationMsg, {
//           chat_id: chatId,
//           message_id: query.message.message_id,
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üìç Current City', callback_data: 'location_current' },
//                 { text: 'üèôÔ∏è Nearby Cities', callback_data: 'location_nearby' }
//               ],
//               [
//                 { text: 'üåÜ Specific City', callback_data: 'location_specific' },
//                 { text: 'üåç Anywhere', callback_data: 'location_anywhere' }
//               ],
//               [
//                 { text: 'üîô Back to Search', callback_data: 'back_to_search' }
//               ]
//             ]
//           }
//         });
//         break;

//       case 'location_current':
//       case 'location_nearby':
//       case 'location_specific':
//       case 'location_anywhere':
//         const locationType = data.replace('location_', '');
//         let locationPreference;
//         let locationText;

//         switch (locationType) {
//           case 'current':
//             locationPreference = 'current_city';
//             locationText = 'Current City';
//             break;
//           case 'nearby':
//             locationPreference = 'nearby_cities';
//             locationText = 'Nearby Cities';
//             break;
//           case 'specific':
//             locationPreference = 'specific_city';
//             locationText = 'Specific City';
//             break;
//           case 'anywhere':
//             locationPreference = null;
//             locationText = 'Anywhere';
//             break;
//         }

//         try {
//           await axios.post(`${API_BASE}/search-settings/${telegramId}`, {
//             locationPreference
//           });
//           bot.sendMessage(chatId, `‚úÖ Location preference updated to ${locationText}!`);
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Failed to update location preference. Please try again.');
//         }
//         break;

//       case 'reset_search':
//         try {
//           await axios.delete(`${API_BASE}/search-settings/${telegramId}`);
//           bot.sendMessage(chatId, 'üîÑ Search settings have been reset to defaults!\n\n‚Ä¢ Age Range: 18-35 years\n‚Ä¢ Max Distance: 50 km\n‚Ä¢ Gender: Any\n‚Ä¢ Location: Any');
//         } catch (err) {
//           console.error('Reset search error:', err.response?.data || err.message);
//           bot.sendMessage(chatId, '‚ùå Failed to reset search settings. Please try again.');
//         }
//         break;

//       case 'back_to_search':
//         // Re-trigger the search command
//         try {
//           const res = await axios.get(`${API_BASE}/search-settings/${telegramId}`);
//           const settings = res.data;

//           const settingsMsg = `üîç **SEARCH SETTINGS** üîç\n\n` +
//             `üìä **Current Preferences:**\n` +
//             `‚Ä¢ Age Range: ${settings.ageMin}-${settings.ageMax} years\n` +
//             `‚Ä¢ Max Distance: ${settings.maxDistance} km\n` +
//             `‚Ä¢ Gender: ${settings.genderPreference}\n` +
//             `‚Ä¢ Location: ${settings.locationPreference || 'Any'}\n\n` +
//             `‚öôÔ∏è **Customize your search to find better matches!**`;

//           const opts = {
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   { text: 'üë• Age Range', callback_data: 'set_age_range' },
//                   { text: 'üìç Distance', callback_data: 'set_distance' }
//                 ],
//                 [
//                   { text: '‚ößÔ∏è Gender Preference', callback_data: 'set_gender_pref' },
//                   { text: 'üåç Location', callback_data: 'set_location_pref' }
//                 ],
//                 [
//                   { text: 'üíé Premium Filters', callback_data: 'premium_filters' },
//                   { text: 'üîÑ Reset Settings', callback_data: 'reset_search' }
//                 ]
//               ]
//             }
//           };

//           bot.sendMessage(chatId, settingsMsg, opts);
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Failed to load search settings.');
//         }
//         break;

//       case 'extend_vip':
//         bot.sendMessage(chatId, 'Choose a plan to extend your VIP membership:', {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üìÖ Monthly', callback_data: 'vip_purchase_monthly' },
//                 { text: 'üìÜ Yearly', callback_data: 'vip_purchase_yearly' }
//               ],
//               [{ text: '‚ôæÔ∏è Lifetime', callback_data: 'vip_purchase_lifetime' }]
//             ]
//           }
//         });
//         break;

//       case 'pass':
//         // Continue showing next profile for browse command
//         sendNextProfile(chatId, telegramId);
//         break;

//       case 'manage_vip':
//         try {
//           const vipRes = await axios.get(`${API_BASE}/vip/${telegramId}`);
//           const vipData = vipRes.data;

//           let vipMsg;
//           let buttons;

//           if (vipData.isVip) {
//             const expiresAt = new Date(vipData.expiresAt).toLocaleDateString();
//             const subscriptionType = vipData.subscriptionType.charAt(0).toUpperCase() + vipData.subscriptionType.slice(1);
            
//             vipMsg = `üëë **VIP STATUS** üëë\n\n` +
//               `‚úÖ **You are VIP!**\n` +
//               `üìÖ Expires: ${vipData.subscriptionType === 'lifetime' ? 'Never' : expiresAt}\n` +
//               `\nYour Benefits:\n` +
//               `üîÑ Extra Swipes: ${vipData.benefits.extraSwipes}\n` +
//               `üö´ Ad-Free Experience\n` +
//               `‚ö°Ô∏è Priority Matching\n` +
//               `üëÄ See Profile Viewers\n` +
//               `üí´ Special Profile Badge`;

//             buttons = [
//               [
//                 { text: 'üîÑ Extend VIP', callback_data: 'extend_vip' },
//                 { text: 'üìä VIP Stats', callback_data: 'vip_stats' }
//               ],
//               [
//                 { text: 'üéÅ VIP Perks', callback_data: 'vip_perks' }
//               ],
//               [
//                 { text: 'üîô Back to Premium', callback_data: 'settings_premium' }
//               ]
//             ];
//           } else {
//             vipMsg = `üëë **GET VIP MEMBERSHIP** üëë\n\n` +
//               `üöÄ **Unlock Premium Features:**\n` +
//               `‚Ä¢ ‚ù§Ô∏è Unlimited likes\n` +
//               `‚Ä¢ üëÄ See who liked you\n` +
//               `‚Ä¢ üîç Advanced search filters\n` +
//               `‚Ä¢ ‚≠ê Priority profile visibility\n` +
//               `‚Ä¢ üö´ No advertisements\n` +
//               `‚Ä¢ üéÅ Exclusive features\n\n` +
//               `üíé **Available VIP Plans:**`;

//             buttons = [
//               [
//                 { text: 'üëë 1 Month VIP (2000 coins)', callback_data: 'vip_1month' },
//                 { text: 'üíé 3 Months VIP (5000 coins)', callback_data: 'vip_3months' }
//               ],
//               [
//                 { text: 'üåü 6 Months VIP (8000 coins)', callback_data: 'vip_6months' },
//                 { text: 'üî• 1 Year VIP (12000 coins)', callback_data: 'vip_1year' }
//               ],
//               [
//                 { text: 'ü™ô Buy Coins First', callback_data: 'buy_coins' }
//               ],
//               [
//                 { text: 'üîô Back to Premium', callback_data: 'settings_premium' }
//               ]
//             ];
//           }

//           // Try to edit first, if it fails, send new message
//           try {
//             bot.editMessageText(vipMsg, {
//               chat_id: chatId,
//               message_id: query.message.message_id,
//               reply_markup: {
//                 inline_keyboard: buttons
//               }
//             });
//           } catch (editErr) {
//             bot.sendMessage(chatId, vipMsg, {
//               reply_markup: {
//                 inline_keyboard: buttons
//               }
//             });
//           }

//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Failed to load VIP information. Please try again.');
//         }
//         break;

//       case 'vip_1month':
//       case 'vip_3months':
//       case 'vip_6months':
//       case 'vip_1year':
//         const vipPlan = data.replace('vip_', '');
//         let duration, cost;

//         switch (vipPlan) {
//           case '1month':
//             duration = 30;
//             cost = 2000;
//             break;
//           case '3months':
//             duration = 90;
//             cost = 5000;
//             break;
//           case '6months':
//             duration = 180;
//             cost = 8000;
//             break;
//           case '1year':
//             duration = 365;
//             cost = 12000;
//             break;
//         }

//         try {
//           const purchaseRes = await axios.post(`${API_BASE}/vip/purchase/${telegramId}`, {
//             duration,
//             cost
//           });

//           if (purchaseRes.data.success) {
//             const expiresAt = new Date(purchaseRes.data.expiresAt);
//             bot.sendMessage(chatId, `üéâ **VIP ACTIVATED!** üéâ\n\n` +
//               `üëë Welcome to VIP membership!\n` +
//               `‚è∞ Valid until: ${expiresAt.toLocaleDateString()}\n` +
//               `üí∞ Cost: ${cost} coins\n\n` +
//               `‚ú® **Your VIP benefits are now active:**\n` +
//               `‚Ä¢ Unlimited likes\n` +
//               `‚Ä¢ See who liked you\n` +
//               `‚Ä¢ Advanced filters\n` +
//               `‚Ä¢ Priority visibility\n\n` +
//               `üöÄ Start exploring with your new powers!`);
//           } else {
//             bot.sendMessage(chatId, `‚ùå **VIP Purchase Failed**\n\n${purchaseRes.data.message}\n\nüí° Try buying more coins first!`);
//           }
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Failed to purchase VIP. Please try again or contact support.');
//         }
//         break;

//       case 'vip_stats':
//         try {
//           const vipRes = await axios.get(`${API_BASE}/vip/${telegramId}`);
//           const vipData = vipRes.data;

//           if (!vipData.isVip) {
//             bot.sendMessage(chatId, '‚ùå You need VIP membership to view stats.');
//             return;
//           }

//           const expiresAt = new Date(vipData.vipDetails.expiresAt);
//           const daysLeft = Math.max(0, Math.ceil((expiresAt - new Date()) / (1000 * 60 * 60 * 24)));
//           const subscriptionType = vipData.vipDetails.subscriptionType || 'Unknown';
          
//           const statsMsg = `üìä **VIP STATISTICS** üìä\n\n` +
//             `üëë **Membership Type:** ${subscriptionType.charAt(0).toUpperCase() + subscriptionType.slice(1)}\n` +
//             `‚è∞ **Expires:** ${expiresAt.toLocaleDateString()}\n` +
//             `üìÖ **Days Remaining:** ${daysLeft} ${daysLeft === 1 ? 'day' : 'days'}\n` +
//             `‚ú® **Status:** ${daysLeft > 0 ? 'Active' : 'Expired'}\n\n` +
//             `üéØ **VIP Benefits Used:**\n` +
//             `‚Ä¢ Extra Swipes: ${vipData.vipDetails.benefits?.extraSwipes || 0}\n` +
//             `‚Ä¢ Ad-Free Experience: ‚úÖ\n` +
//             `‚Ä¢ Priority Matching: ‚úÖ\n` +
//             `‚Ä¢ See Profile Viewers: ‚úÖ\n` +
//             `‚Ä¢ Special VIP Badge: ‚úÖ`;

//           const buttons = [
//             [
//               { text: 'üîÑ Extend VIP', callback_data: 'extend_vip' }
//             ],
//             [
//               { text: 'üîô Back to VIP', callback_data: 'manage_vip' }
//             ]
//           ];

//           bot.editMessageText(statsMsg, {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: {
//               inline_keyboard: buttons
//             }
//           });

//         } catch (err) {
//           console.error('VIP stats error:', err);
//           bot.sendMessage(chatId, '‚ùå Failed to load VIP statistics. Please try again.');
//         }
//         break;

//       case 'vip_perks':
//         try {
//           const vipRes = await axios.get(`${API_BASE}/vip/${telegramId}`);
//           const vipData = vipRes.data;

//           if (!vipData.isVip) {
//             bot.sendMessage(chatId, '‚ùå You need VIP membership to view perks.');
//             return;
//           }

//           const perksMsg = `üéÅ **VIP EXCLUSIVE PERKS** üéÅ\n\n` +
//             `‚ú® **Active Benefits:**\n\n` +
//             `‚ù§Ô∏è **Unlimited Likes**\n` +
//             `‚Ä¢ Like as many profiles as you want\n` +
//             `‚Ä¢ No daily limits or restrictions\n\n` +
//             `üëÄ **See Who Liked You**\n` +
//             `‚Ä¢ View all your admirers instantly\n` +
//             `‚Ä¢ Never miss a potential match\n\n` +
//             `üîç **Advanced Search Filters**\n` +
//             `‚Ä¢ Filter by interests, education, job\n` +
//             `‚Ä¢ Find your perfect match faster\n\n` +
//             `‚≠ê **Priority Profile Visibility**\n` +
//             `‚Ä¢ Your profile appears first in searches\n` +
//             `‚Ä¢ Get 10x more profile views\n\n` +
//             `üö´ **Ad-Free Experience**\n` +
//             `‚Ä¢ No interruptions while browsing\n` +
//             `‚Ä¢ Smooth, premium experience\n\n` +
//             `üëë **VIP Badge**\n` +
//             `‚Ä¢ Stand out with exclusive VIP status\n` +
//             `‚Ä¢ Show you're serious about dating`;

//           const buttons = [
//             [
//               { text: 'üìä View Stats', callback_data: 'vip_stats' }
//             ],
//             [
//               { text: 'üîô Back to VIP', callback_data: 'manage_vip' }
//             ]
//           ];

//           bot.editMessageText(perksMsg, {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: {
//               inline_keyboard: buttons
//             }
//           });

//         } catch (err) {
//           console.error('VIP perks error:', err);
//           bot.sendMessage(chatId, '‚ùå Failed to load VIP perks. Please try again.');
//         }
//         break;

//       // Help menu handlers
//       case 'view_profile':
//         try {
//           const profileRes = await axios.get(`${API_BASE}/profile/${telegramId}`);
//           const user = profileRes.data;

//           let profileMsg = `üë§ **YOUR PROFILE** üë§\n\n`;
//           profileMsg += `üìù **Basic Info:**\n`;
//           profileMsg += `‚Ä¢ Name: ${user.name}\n`;
//           profileMsg += `‚Ä¢ Age: ${user.age}\n`;
//           profileMsg += `‚Ä¢ Location: ${user.location || 'Not set'}\n\n`;
          
//           if (user.bio) {
//             profileMsg += `üí≠ **Bio:** ${user.bio}\n\n`;
//           }
          
//           profileMsg += `üì∏ **Photos:** ${user.photos?.length || 0} uploaded\n`;
//           profileMsg += `üíé **Status:** ${user.isVip ? 'üëë VIP Member' : 'Regular Member'}\n`;
//           profileMsg += `ü™ô **Coins:** ${user.coins || 0}`;

//           bot.editMessageText(profileMsg, {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   { text: '‚úèÔ∏è Edit Profile', callback_data: 'settings_profile' },
//                   { text: 'üì∏ Add Photos', callback_data: 'manage_photos' }
//                 ],
//                 [
//                   { text: 'üîô Back to Help', callback_data: 'show_help' }
//                 ]
//               ]
//             }
//           });
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Failed to load your profile. Please try /register first.');
//         }
//         break;

//       case 'browse_profiles':
//         try {
//           const browseRes = await axios.get(`${API_BASE}/browse/${telegramId}`);
//           const profiles = browseRes.data;

//           if (!profiles || profiles.length === 0) {
//             bot.editMessageText(
//               `üîç **BROWSE PROFILES** üîç\n\n` +
//               `üòî No profiles available right now.\n\n` +
//               `üí° **Tips:**\n` +
//               `‚Ä¢ Complete your profile first\n` +
//               `‚Ä¢ Adjust your search preferences\n` +
//               `‚Ä¢ Check back later for new users\n\n` +
//               `üöÄ **Get started:**`,
//               {
//                 chat_id: chatId,
//                 message_id: query.message.message_id,
//                 reply_markup: {
//                   inline_keyboard: [
//                     [
//                       { text: 'üë§ Complete Profile', callback_data: 'settings_profile' },
//                       { text: 'üîç Search Settings', callback_data: 'settings_search' }
//                     ],
//                     [
//                       { text: 'üîô Back to Help', callback_data: 'show_help' }
//                     ]
//                   ]
//                 }
//               }
//             );
//           } else {
//             // Start browsing with first profile
//             sendNextProfile(chatId, telegramId);
//           }
//         } catch (err) {
//           bot.sendMessage(chatId, '‚ùå Failed to load profiles. Please try again later.');
//         }
//         break;

//       case 'main_settings':
//         bot.editMessageText(
//           `‚öôÔ∏è **SETTINGS MENU** ‚öôÔ∏è\n\n` +
//           `Customize your Kisu1bot experience!\n\n` +
//           `üë§ **Profile Settings**\n` +
//           `‚Ä¢ Edit your profile information\n` +
//           `‚Ä¢ Update photos and bio\n` +
//           `‚Ä¢ Privacy preferences\n\n` +
//           `üîç **Search Preferences**\n` +
//           `‚Ä¢ Age range and distance\n` +
//           `‚Ä¢ Gender preferences\n` +
//           `‚Ä¢ Location settings\n\n` +
//           `üíé **Premium Features**\n` +
//           `‚Ä¢ VIP membership\n` +
//           `‚Ä¢ Coins and purchases\n` +
//           `‚Ä¢ Priority features\n\n` +
//           `üîî **Notifications**\n` +
//           `‚Ä¢ Match notifications\n` +
//           `‚Ä¢ Message alerts\n` +
//           `‚Ä¢ Activity updates`,
//           {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   { text: 'üë§ Profile Settings', callback_data: 'settings_profile' },
//                   { text: 'üîç Search Preferences', callback_data: 'settings_search' }
//                 ],
//                 [
//                   { text: 'üíé Premium Features', callback_data: 'settings_premium' },
//                   { text: 'üîî Notifications', callback_data: 'settings_notifications' }
//                 ],
//                 [
//                   { text: 'üîí Privacy & Safety', callback_data: 'settings_privacy' },
//                   { text: 'üõ†Ô∏è Account Settings', callback_data: 'settings_account' }
//                 ],
//                 [
//                   { text: '‚ùì Help & Support', callback_data: 'settings_help' }
//                 ]
//               ]
//             }
//           }
//         );
//         break;

//       case 'email_support':
//         bot.sendMessage(chatId, `üìß **EMAIL SUPPORT** üìß\n\n` +
//           `Send your support request to:\n` +
//           `üìÆ **spprtksbt@gmail.com**\n\n` +
//           `üìã **Please include:**\n` +
//           `‚Ä¢ Your Telegram username: @${query.from.username || 'N/A'}\n` +
//           `‚Ä¢ Your user ID: ${telegramId}\n` +
//           `‚Ä¢ Detailed description of your issue\n` +
//           `‚Ä¢ Screenshots if relevant\n\n` +
//           `‚è∞ **Response time:** 24-48 hours\n\n` +
//           `üí° **Tip:** Copy the email address above and paste it in your email app.`);
//         break;


//       case 'contact_support':
//         const supportMsg = `üìû **CONTACT SUPPORT** üìû\n\n` +
//           `Our support team is here to help!\n\n` +
//           `üïê **Support Hours:**\n` +
//           `Monday - Friday: 9 AM - 6 PM UTC\n` +
//           `Weekend: Limited support\n\n` +
//           `üìß **Contact Methods:**\n` +
//           `‚Ä¢ Email: spprtksbt@gmail.com\n` +
//           `‚Ä¢ Response time: 24-48 hours\n\n` +
//           `üí¨ **Common Issues:**\n` +
//           `‚Ä¢ Profile not showing up\n` +
//           `‚Ä¢ Payment/VIP problems\n` +
//           `‚Ä¢ Technical difficulties\n` +
//           `‚Ä¢ Account recovery\n` +
//           `‚Ä¢ Report violations\n\n` +
//           `üìã **Before contacting:**\n` +
//           `‚Ä¢ Check /help for common solutions\n` +
//           `‚Ä¢ Include your Telegram username\n` +
//           `‚Ä¢ Describe the issue clearly`;

//         const supportOpts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üìß Email Support', callback_data: 'email_support' }
//               ],
//               [
//                 { text: 'üö® Report Issue', callback_data: 'report_user' },
//                 { text: '‚ùì FAQ/Help', callback_data: 'show_help' }
//               ],
//               [
//                 { text: 'üí¨ Send Feedback', callback_data: 'send_feedback' }
//               ]
//             ]
//           }
//         };

//         // Try to edit first, if it fails, send new message
//         try {
//           bot.editMessageText(supportMsg, {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: supportOpts.reply_markup
//           });
//         } catch (editErr) {
//           bot.sendMessage(chatId, supportMsg, supportOpts);
//         }
//         break;

//       case 'send_feedback':
//         bot.editMessageText(
//           `üí¨ **SEND FEEDBACK** üí¨\n\n` +
//           `We value your opinion and suggestions!\n\n` +
//           `üìù **Feedback Types:**\n` +
//           `‚Ä¢ Feature requests\n` +
//           `‚Ä¢ User experience improvements\n` +
//           `‚Ä¢ Bug reports\n` +
//           `‚Ä¢ General suggestions\n` +
//           `‚Ä¢ Compliments or complaints\n\n` +
//           `üìß **Send feedback to:**\n` +
//           `feedback@kisu1bot.com\n\n` +
//           `üí° **Please include:**\n` +
//           `‚Ä¢ Your Telegram username\n` +
//           `‚Ä¢ Detailed description\n` +
//           `‚Ä¢ Screenshots if relevant\n\n` +
//           `üôè Thank you for helping us improve!`,
//           {
//             chat_id: chatId,
//             message_id: query.message.message_id,
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   { text: 'üìß Send Feedback', callback_data: 'email_feedback' }
//                 ],
//                 [
//                   { text: 'üîô Back to Support', callback_data: 'contact_support' }
//                 ]
//               ]
//             }
//           }
//         );
//         break;

//       case 'email_feedback':
//         bot.sendMessage(chatId, `üìß **SEND FEEDBACK** üìß\n\n` +
//           `Share your thoughts with us:\n` +
//           `üìÆ **feedback@kisu1bot.com**\n\n` +
//           `üìã **We'd love to hear about:**\n` +
//           `‚Ä¢ Feature suggestions\n` +
//           `‚Ä¢ User experience improvements\n` +
//           `‚Ä¢ What you like about the app\n` +
//           `‚Ä¢ What could be better\n\n` +
//           `üìù **Include your username:** @${query.from.username || 'N/A'}\n\n` +
//           `üôè **Thank you for helping us improve Kisu1bot!**`);
//         break;

//       case 'cancel_delete':
//         bot.sendMessage(chatId, `‚úÖ **Profile Deletion Cancelled** ‚úÖ\n\n` +
//           `Your profile is safe and remains active.\n\n` +
//           `üí° **Need help instead?**\n` +
//           `‚Ä¢ Use /help for guidance\n` +
//           `‚Ä¢ Contact support with /contact\n` +
//           `‚Ä¢ Adjust settings with /settings\n\n` +
//           `Thank you for staying with Kisu1bot! üíï`);
//         break;

//       case 'deactivate_profile':
//         try {
//           const res = await axios.post(`${API_BASE}/users/deactivate/${telegramId}`);
          
//           const deactivateMsg = `‚è∏Ô∏è **Profile Deactivated** ‚è∏Ô∏è\n\n` +
//             `Your profile has been temporarily deactivated.\n\n` +
//             `üìã **What this means:**\n` +
//             `‚Ä¢ Your profile is hidden from other users\n` +
//             `‚Ä¢ You won't receive new matches\n` +
//             `‚Ä¢ Your data is safely stored\n` +
//             `‚Ä¢ You can reactivate anytime\n\n` +
//             `üîÑ **To reactivate:** Use /start when you're ready to return\n\n` +
//             `üí° **Need help?** Contact support anytime with /contact`;

//           bot.sendMessage(chatId, deactivateMsg, {
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   { text: 'üîÑ Reactivate Now', callback_data: 'reactivate_profile' },
//                   { text: 'üìû Contact Support', callback_data: 'contact_support' }
//                 ]
//               ]
//             }
//           });
//         } catch (err) {
//           console.error('Deactivate profile error:', err.response?.data || err.message);
//           bot.sendMessage(chatId, '‚ùå Failed to deactivate your profile. Please try again later or contact support.');
//         }
//         break;

//       case 'reactivate_profile':
//         try {
//           const res = await axios.post(`${API_BASE}/users/reactivate/${telegramId}`);
          
//           bot.sendMessage(chatId, `üéâ **Welcome Back!** üéâ\n\n` +
//             `Your profile has been reactivated successfully!\n\n` +
//             `‚úÖ **You're back in action:**\n` +
//             `‚Ä¢ Your profile is visible again\n` +
//             `‚Ä¢ You can receive new matches\n` +
//             `‚Ä¢ All your data is restored\n\n` +
//             `üöÄ **Ready to continue?**\n` +
//             `‚Ä¢ Use /browse to find matches\n` +
//             `‚Ä¢ Update your profile with /profile\n` +
//             `‚Ä¢ Check your settings with /settings\n\n` +
//             `Happy dating! üíï`);
//         } catch (err) {
//           console.error('Reactivate profile error:', err.response?.data || err.message);
//           bot.sendMessage(chatId, '‚ùå Failed to reactivate your profile. Please try again later or contact support.');
//         }
//         break;

//       case 'confirm_delete_profile':
//         // Show final warning before permanent deletion
//         const finalWarningMsg = `üö® **FINAL WARNING** üö®\n\n` +
//           `‚ö†Ô∏è **THIS WILL PERMANENTLY DELETE YOUR PROFILE**\n\n` +
//           `üóëÔ∏è **What will be deleted:**\n` +
//           `‚Ä¢ All your profile information\n` +
//           `‚Ä¢ All your photos\n` +
//           `‚Ä¢ All your matches and conversations\n` +
//           `‚Ä¢ Your VIP status and coins\n` +
//           `‚Ä¢ All your activity history\n\n` +
//           `‚ùå **This action CANNOT be undone!**\n\n` +
//           `üíî Are you absolutely sure you want to delete everything?`;

//         const finalOpts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üóëÔ∏è Yes, Delete Everything', callback_data: 'final_confirm_delete' }
//               ],
//               [
//                 { text: '‚ùå Cancel - Keep My Account', callback_data: 'cancel_delete' }
//               ]
//             ]
//           }
//         };

//         bot.sendMessage(chatId, finalWarningMsg, finalOpts);
//         break;

//       case 'final_confirm_delete':
//         try {
//           const res = await axios.delete(`${API_BASE}/users/delete/${telegramId}`);
          
//           bot.sendMessage(chatId, `üíî **Profile Deleted** üíî\n\n` +
//             `Your profile has been permanently deleted from Kisu1bot.\n\n` +
//             `üôè **Thank you for using Kisu1bot**\n\n` +
//             `If you ever want to return:\n` +
//             `‚Ä¢ Use /start to create a new profile\n` +
//             `‚Ä¢ Contact us if you need help\n\n` +
//             `We're sorry to see you go. Take care! üíï`);
//         } catch (err) {
//           console.error('Delete profile error:', err.response?.data || err.message);
//           bot.sendMessage(chatId, '‚ùå Failed to delete your profile. Please contact support for assistance.');
//         }
//         break;

//     }
//   }
// });

// // LIKESYOU (VIP Only)
// bot.onText(/\/likesyou/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     const res = await axios.get(`${API_BASE}/matches/${telegramId}`);
//     const matches = res.data;

//     if (!matches.length) {
//       return bot.sendMessage(
//         chatId, 
//         'üíî No matches yet.\nUse /browse to start matching with people!'
//       );
//     }

//     // Send a summary message
//     const summaryMsg = `üíï Your Matches (${matches.length})\n` +
//       'Here are the people you\'ve matched with:';
//     await bot.sendMessage(chatId, summaryMsg);

//     // Send each match with interaction buttons
//     for (const match of matches) {
//       const matchTime = new Date(match.matchedAt).toLocaleDateString();
//       const lastMessageTime = match.lastMessage?.sentAt ? 
//         new Date(match.lastMessage.sentAt).toLocaleString() : null;

//       const matchMsg = [
//         `üë§ ${match.name || 'No name'} ${match.isVip ? 'üëë' : ''}`,
//         `üìç ${match.location || 'Location not set'}`,
//         `üéÇ ${match.age || 'Age not set'} years old`,
//         `üìù ${match.bio || 'No bio'}`,
//         `\nü§ù Matched on: ${matchTime}`,
//         lastMessageTime ? `\nüí¨ Last message: ${match.lastMessage.text}\n‚è∞ ${lastMessageTime}` : '',
//         match.unreadCount ? `\nüì´ ${match.unreadCount} unread messages` : ''
//       ].join('\n');

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üí¨ Chat', callback_data: `chat_${match.userId}` },
//               { text: '‚ùå Unmatch', callback_data: `unmatch_${match.userId}` }
//             ]
//           ]
//         }
//       };

//       await bot.sendMessage(chatId, matchMsg, opts);
//     }

//     // Add a helpful tip at the end
//     const tipMsg = '\nüí° Tip: Keep the conversation going! Active chats lead to better matches.';
//     await bot.sendMessage(chatId, tipMsg);

//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to retrieve matches.');
//   }
// });

// // Profile command
// bot.onText(/\/profile/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     const res = await axios.get(`${API_BASE}/profile/${telegramId}`);
//     const profile = res.data;
//     const profileText = `Your Profile:\nName: ${profile.name || 'Not set'}\nAge: ${profile.age || 'Not set'}\nLocation: ${profile.location || 'Not set'}\nBio: ${profile.bio || 'Not set'}`;
    
//     const opts = {
//       reply_markup: {
//         inline_keyboard: [[
//           { text: '‚úèÔ∏è Edit Profile', callback_data: 'edit_profile' }
//         ]]
//       }
//     };
    
//     bot.sendMessage(chatId, profileText, opts);
//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to fetch profile.');
//   }
// });

// // Profile editing commands
// bot.onText(/\/setname (.+)/, async (msg, match) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
//   const name = match[1];

//   try {
//     await axios.post(`${API_BASE}/profile/update/${telegramId}`, {
//       field: 'name',
//       value: name
//     });
//     bot.sendMessage(chatId, `Name updated to: ${name}`);
//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to update name.');
//   }
// });

// bot.onText(/\/setage (.+)/, async (msg, match) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
//   const age = parseInt(match[1]);

//   if (isNaN(age) || age < 18 || age > 100) {
//     return bot.sendMessage(chatId, 'Please enter a valid age between 18 and 100.');
//   }

//   try {
//     await axios.post(`${API_BASE}/profile/update/${telegramId}`, {
//       field: 'age',
//       value: age
//     });
//     bot.sendMessage(chatId, `Age updated to: ${age}`);
//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to update age.');
//   }
// });

// bot.onText(/\/setlocation (.+)/, async (msg, match) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
//   const location = match[1];

//   try {
//     await axios.post(`${API_BASE}/profile/update/${telegramId}`, {
//       field: 'location',
//       value: location
//     });
//     bot.sendMessage(chatId, `Location updated to: ${location}`);
//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to update location.');
//   }
// });

// bot.onText(/\/setbio (.+)/, async (msg, match) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
//   const bio = match[1];

//   if (bio.length > 300) {
//     return bot.sendMessage(chatId, 'Bio must be 300 characters or less.');
//   }

//   try {
//     await axios.post(`${API_BASE}/profile/update/${telegramId}`, {
//       field: 'bio',
//       value: bio
//     });
//     bot.sendMessage(chatId, `Bio updated successfully! Use /profile to view your profile.`);
//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to update bio.');
//   }
// });

// // Likes You command
// bot.onText(/\/likesyou/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     const res = await axios.get(`${API_BASE}/likes/${telegramId}`);
//     const { likes, totalLikes, visibleLikes, hasHiddenLikes, isVip } = res.data;

//     if (totalLikes === 0) {
//       return bot.sendMessage(
//         chatId,
//         'üíî No one has liked your profile yet.\n' +
//         'Use /browse to find more people!'
//       );
//     }

//     // Send summary message
//     let summaryMsg = `‚ù§Ô∏è People Who Like You (${totalLikes})\n`;
//     if (hasHiddenLikes) {
//       summaryMsg += `\nüëÄ Showing ${visibleLikes} of ${totalLikes} likes` +
//         '\nüí´ Get VIP to see all likes!';
//     }
//     await bot.sendMessage(chatId, summaryMsg);

//     // Send each visible like with interaction buttons
//     for (const user of likes) {
//       const likeMsg = [
//         `üë§ ${user.name || 'Anonymous'} ${user.isVip ? 'üëë' : ''}`,
//         `üìç ${user.location || 'Location not set'}`,
//         `üéÇ ${user.age || 'Age not set'} years old`,
//         `üìù ${user.bio || 'No bio'}`
//       ].join('\n');

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [[
//             { text: '‚ù§Ô∏è Like Back', callback_data: `like_${user.telegramId}` },
//             { text: 'üëé Pass', callback_data: `pass_like_${user.telegramId}` }
//           ]]
//         }
//       };

//       await bot.sendMessage(chatId, likeMsg, opts);
//     }

//     // If there are hidden likes, show VIP promotion
//     if (hasHiddenLikes && !isVip) {
//       const hiddenCount = totalLikes - visibleLikes;
//       const vipMsg = `üîí ${hiddenCount} more ${hiddenCount === 1 ? 'person likes' : 'people like'} you!\n` +
//         'üëë Get VIP to:\n' +
//         '‚Ä¢ See all likes\n' +
//         '‚Ä¢ Get priority matching\n' +
//         '‚Ä¢ And more benefits!';

//       const vipOpts = {
//         reply_markup: {
//           inline_keyboard: [[
//             { text: '‚≠êÔ∏è Get VIP', callback_data: 'manage_vip' }
//           ]]
//         }
//       };

//       await bot.sendMessage(chatId, vipMsg, vipOpts);
//     }

//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to fetch likes.');
//   }
// });

// // Search Settings command
// bot.onText(/\/search/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     const res = await axios.get(`${API_BASE}/search-settings/${telegramId}`);
//     const settings = res.data || {};

//     const settingsMsg = `üîç **SEARCH SETTINGS** üîç\n\n` +
//       `üìä **Current Preferences:**\n` +
//       `‚Ä¢ Age Range: ${settings.ageMin || 18}-${settings.ageMax || 99} years\n` +
//       `‚Ä¢ Max Distance: ${settings.maxDistance ? settings.maxDistance + ' km' : 'Unlimited'}\n` +
//       `‚Ä¢ Gender: ${settings.genderPreference || 'Any'}\n` +
//       `‚Ä¢ Location: ${settings.locationPreference || 'Any'}\n\n` +
//       `‚öôÔ∏è **Customize your search to find better matches!**`;

//     const opts = {
//       reply_markup: {
//         inline_keyboard: [
//           [
//             { text: 'üë• Gender Preference', callback_data: 'search_gender' },
//             { text: 'üéÇ Age Range', callback_data: 'search_age' }
//           ],
//           [
//             { text: 'üìç Distance', callback_data: 'search_distance' },
//             { text: 'üåç Location', callback_data: 'search_location' }
//           ],
//           [
//             { text: 'üîÑ Reset All', callback_data: 'search_reset' },
//             { text: '‚úÖ Done', callback_data: 'search_done' }
//           ]
//         ]
//       }
//     };

//     bot.sendMessage(chatId, settingsMsg, opts);
//   } catch (err) {
//     // If user doesn't have settings yet, create default ones
//     const defaultMsg = `üîç **SEARCH SETTINGS** üîç\n\n` +
//       `üìä **Default Preferences:**\n` +
//       `‚Ä¢ Age Range: 18-35 years\n` +
//       `‚Ä¢ Max Distance: 50 km\n` +
//       `‚Ä¢ Gender: Any\n` +
//       `‚Ä¢ Location: Any\n\n` +
//       `‚öôÔ∏è **Customize your search to find better matches!**`;

//     const opts = {
//       reply_markup: {
//         inline_keyboard: [
//           [
//             { text: 'üë• Gender Preference', callback_data: 'search_gender' },
//             { text: 'üéÇ Age Range', callback_data: 'search_age' }
//           ],
//           [
//             { text: 'üìç Distance', callback_data: 'search_distance' },
//             { text: 'üåç Location', callback_data: 'search_location' }
//           ],
//           [
//             { text: 'üîÑ Reset All', callback_data: 'search_reset' },
//             { text: '‚úÖ Done', callback_data: 'search_done' }
//           ]
//         ]
//       }
//     };

//     bot.sendMessage(chatId, defaultMsg, opts);
//   }
// });

// // Gifts command
// bot.onText(/\/gifts/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     const res = await axios.get(`${API_BASE}/gifts/${telegramId}`);
//     const { sentGifts, receivedGifts, giftStats, coinBalance } = res.data;

//     const giftsMsg = `üéÅ **GIFT CENTER** üéÅ\n\n` +
//       `üí∞ Your Coins: ${coinBalance || 0}\n\n` +
//       `üìä **Gift Statistics:**\n` +
//       `‚Ä¢ Gifts Sent: ${giftStats?.totalSent || 0}\n` +
//       `‚Ä¢ Gifts Received: ${giftStats?.totalReceived || 0}\n` +
//       `‚Ä¢ Favorite Gift: ${giftStats?.favoriteGift || 'None'}\n\n` +
//       `Choose what you'd like to do:`;

//     const opts = {
//       reply_markup: {
//         inline_keyboard: [
//           [
//             { text: 'üéÅ Send Gift', callback_data: 'gifts_send' },
//             { text: 'üì• Received Gifts', callback_data: 'gifts_received' }
//           ],
//           [
//             { text: 'üì§ Sent Gifts', callback_data: 'gifts_sent' },
//             { text: 'üõçÔ∏è Gift Shop', callback_data: 'gifts_shop' }
//           ],
//           [
//             { text: 'üìä Gift Analytics', callback_data: 'gifts_analytics' },
//             { text: '‚ùì Gift Guide', callback_data: 'gifts_help' }
//           ]
//         ]
//       }
//     };

//     bot.sendMessage(chatId, giftsMsg, opts);

//   } catch (err) {
//     console.error('[/gifts] Error:', err.response?.data || err.message);
    
//     // Show default gifts menu if API fails
//     const defaultMsg = `üéÅ **GIFT CENTER** üéÅ\n\n` +
//       `Send virtual gifts to show someone you care!\n\n` +
//       `Choose what you'd like to do:`;

//     const opts = {
//       reply_markup: {
//         inline_keyboard: [
//           [
//             { text: 'üéÅ Send Gift', callback_data: 'gifts_send' },
//             { text: 'üõçÔ∏è Gift Shop', callback_data: 'gifts_shop' }
//           ],
//           [
//             { text: 'üí∞ Buy Coins', callback_data: 'buy_coins' },
//             { text: '‚ùì Gift Guide', callback_data: 'gifts_help' }
//           ]
//         ]
//       }
//     };

//     bot.sendMessage(chatId, defaultMsg, opts);
//   }
// });

// // Stories command
// bot.onText(/\/stories/, async (msg) => {
//   const chatId = msg.chat.id;
//   const opts = {
//     reply_markup: {
//       inline_keyboard: [[
//         { text: 'üì± View Stories', callback_data: 'view_stories' },
//         { text: 'üì§ Post Story', callback_data: 'post_story' }
//       ]]
//     }
//   };
//   bot.sendMessage(chatId, 'Stories Menu:', opts);
// });

// // Coins command
// bot.onText(/\/coins/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     const res = await axios.get(`${API_BASE}/coins/${telegramId}`);
//     const { coins, packages } = res.data;

//     // Create the main balance message
//     const balanceMsg = `üí∞ Your Coin Balance: ${coins} ü™ô\n\n` +
//       'üéÅ Available Packages:';

//     // Create package buttons
//     const packageButtons = Object.entries(packages).map(([id, pack]) => ({
//       text: `${pack.name} (${pack.coins + pack.bonus} coins)`,
//       callback_data: `buy_coins_${id}`
//     }));

//     // Group buttons into pairs
//     const buttonRows = packageButtons.reduce((rows, button, index) => {
//       if (index % 2 === 0) {
//         rows.push([button]);
//       } else {
//         rows[rows.length - 1].push(button);
//       }
//       return rows;
//     }, []);

//     // Add package details to the message
//     const packagesMsg = Object.values(packages).map(pack => 
//       `\n\n${pack.name}:` +
//       `\n‚Ä¢ ${pack.coins} coins` +
//       (pack.bonus ? `\n‚Ä¢ +${pack.bonus} bonus coins` : '') +
//       `\n‚Ä¢ $${pack.price}`
//     ).join('');

//     const opts = {
//       reply_markup: {
//         inline_keyboard: buttonRows
//       }
//     };

//     // Send the complete message
//     bot.sendMessage(
//       chatId,
//       balanceMsg + packagesMsg + '\n\nüí° Coins can be used for VIP membership, gifts, and other premium features!',
//       opts
//     );
//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to fetch coin balance.');
//   }
// });
// // VIP command
// bot.onText(/\/vip/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
//   try {
//     const res = await axios.get(`${API_BASE}/vip/${telegramId}`);
//     const { isVip, vipDetails, availablePlans } = res.data;

//     if (isVip) {
//       const expiryDate = new Date(vipDetails.expiresAt).toLocaleDateString();
//       const subscriptionType = vipDetails.subscriptionType.charAt(0).toUpperCase() + vipDetails.subscriptionType.slice(1);
      
//       const benefitsText = `üëë **VIP STATUS** üëë

// ‚úÖ **You are VIP!**

// üìÖ Expires: ${vipDetails.subscriptionType === 'lifetime' ? 'Never' : expiryDate}

// Your Benefits:

// üîÑ Extra Swipes: ${vipDetails.benefits.extraSwipes}

// üö´ Ad-Free Experience

// ‚ö°Ô∏è Priority Matching

// üëÄ See Profile Viewers

// üí´ Special Profile Badge`;
      
//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [{ text: 'üëë Extend VIP', callback_data: 'extend_vip' }],
//             [{ text: '‚ùå Cancel VIP', callback_data: 'cancel_vip' }]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, benefitsText, opts);
//     } else {
//       const plansText = Object.entries(availablePlans).map(([plan, details]) => {
//         return `\n${plan.toUpperCase()} PLAN - ${details.price} coins
// ‚Ä¢ ${details.duration} days
// ‚Ä¢ ${details.benefits.extraSwipes} extra swipes
// ‚Ä¢ Ad-free experience
// ‚Ä¢ Priority matching
// ‚Ä¢ See who viewed you
// ‚Ä¢ Special badge`;
//       }).join('\n');

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üìÖ Monthly', callback_data: 'vip_purchase_monthly' },
//               { text: 'üìÜ Yearly', callback_data: 'vip_purchase_yearly' }
//             ],
//             [{ text: '‚ôæÔ∏è Lifetime', callback_data: 'vip_purchase_lifetime' }]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, `üåü VIP MEMBERSHIP PLANS ${plansText}`, opts);
//     }
//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to fetch VIP status.');
//   }
// });

// // Priority command
// bot.onText(/\/priority/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;

//   try {
//     const res = await axios.get(`${API_BASE}/priority/${telegramId}`);
//     const { hasPriority, expiresAt, availablePlans } = res.data;

//     let statusMsg = '';
//     if (hasPriority) {
//       const expiryDate = new Date(expiresAt).toLocaleString();
//       statusMsg = `‚ö°Ô∏è You have Priority Status!\n\n` +
//         `Your profile will be shown first until ${expiryDate}\n` +
//         `Remaining coins: ${res.data.remainingCoins} ü™ô`;
//     } else {
//       statusMsg = 'üåü Priority Status\n\n' +
//         'Get your profile shown first to potential matches!\n' +
//         'Benefits:\n' +
//         '‚Ä¢ Appear at the top of browse results\n' +
//         '‚Ä¢ Get more profile views\n' +
//         '‚Ä¢ Increase your match chances';
//     }

//     // Add available plans
//     const plansMsg = '\n\nüìã Available Boost Plans:\n\n' +
//       Object.values(availablePlans).map(plan =>
//         `${plan.name}\n` +
//         `‚Ä¢ ${plan.description}\n` +
//         `‚Ä¢ ${plan.price} coins\n` +
//         `‚Ä¢ ${plan.duration} ${plan.duration === 1 ? 'day' : 'days'}`
//       ).join('');

//     // Create buttons for each plan
//     const buttons = [
//       [
//         { text: '‚ö°Ô∏è Daily (200)', callback_data: 'priority_daily' },
//         { text: 'üöÄ Weekly (1000)', callback_data: 'priority_weekly' }
//       ],
//       [
//         { text: 'üåü Monthly (3000)', callback_data: 'priority_monthly' }
//       ]
//     ];

//     const opts = {
//       reply_markup: {
//         inline_keyboard: buttons
//       }
//     };

//     await bot.sendMessage(chatId, statusMsg + plansMsg, opts);

//   } catch (err) {
//     bot.sendMessage(chatId, 'Failed to fetch priority status.');
//   }
// });

// // Photo upload command
// bot.onText(/\/photo/, async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
  
//   userStates[telegramId] = { uploadingPhoto: true };
//   bot.sendMessage(chatId, 'üì∏ **UPLOAD PHOTO** üì∏\n\nSend me a photo to add to your profile!\n\nüì± Make sure it\'s a clear, high-quality image.\n\n‚ùå Send /cancel to abort.');
// });

// // Handle video uploads for stories
// bot.on('video', async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
  
//   // Check if user is in story posting mode
//   if (userStates[telegramId] && userStates[telegramId].awaitingStory) {
//     try {
//       const video = msg.video;
//       const fileId = video.file_id;
//       const duration = Math.min(video.duration || 15, 30); // Max 30 seconds
      
//       // Get file info from Telegram
//       const file = await bot.getFile(fileId);
//       const videoUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${file.file_path}`;
      
//       // Get caption if provided
//       const caption = msg.caption || '';
      
//       // Post story to backend
//       const response = await axios.post(`${API_BASE}/stories/post/${telegramId}`, {
//         mediaUrl: videoUrl,
//         mediaType: 'video',
//         caption: caption,
//         duration: duration
//       });
      
//       // Clear user state
//       delete userStates[telegramId];
      
//       // Send success message
//       const successMsg = `üé• **VIDEO STORY POSTED!** üé•\n\n` +
//         `‚ú® Your video story is now live for 24 hours!\n` +
//         `‚è±Ô∏è Duration: ${duration} seconds\n\n` +
//         `üìä **What's next?**\n` +
//         `‚Ä¢ Share more stories to boost visibility\n` +
//         `‚Ä¢ Check your story views and analytics\n` +
//         `‚Ä¢ View stories from other users\n` +
//         `‚Ä¢ Use /stories to manage your stories!`;
      
//       await bot.sendMessage(chatId, successMsg, {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üì± View My Stories', callback_data: 'my_stories' },
//               { text: 'üëÄ View Others', callback_data: 'view_stories' }
//             ],
//             [
//               { text: 'üìä Story Analytics', callback_data: 'story_stats' }
//             ]
//           ]
//         },
//         parse_mode: 'Markdown'
//       });
      
//     } catch (err) {
//       console.error('Error posting video story:', err);
//       delete userStates[telegramId];
//       bot.sendMessage(chatId, '‚ùå Failed to post your video story. Please try again later.');
//     }
//   }
// });

// // Photo upload handler
// bot.on('photo', async (msg) => {
//   const chatId = msg.chat.id;
//   const telegramId = msg.from.id;
  
//   // Check if user is in photo upload mode
//   if (userStates[telegramId] && userStates[telegramId].uploadingPhoto) {
//     try {
//       // Get the highest resolution photo
//       const photo = msg.photo[msg.photo.length - 1];
//       const fileId = photo.file_id;
//       const filePath = await bot.getFileLink(fileId);
      
//       // Upload photo to backend using the correct endpoint
//       const UPLOAD_URL = 'https://kisu1bot-backend-repo.onrender.com/api/upload-photo';
//       const response = await axios.post(`${UPLOAD_URL}/${telegramId}`, {
//         image: filePath
//       });
      
//       // Clear user state
//       delete userStates[telegramId];
      
//       // Send success message
//       const successMsg = `üì∏ **PHOTO UPLOADED!** üì∏\n\n` +
//         `‚úÖ Your photo has been added to your profile!\n\n` +
//         `üì± **Next Steps:**\n` +
//         `‚Ä¢ Use /settings to manage more photos\n` +
//         `‚Ä¢ Use /browse to start meeting people\n` +
//         `‚Ä¢ Check /matches to see your connections`;

//       const successOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üì∏ Manage Photos', callback_data: 'manage_photos' },
//               { text: 'üëÄ Browse Profiles', callback_data: 'browse_profiles' }
//             ],
//             [
//               { text: '‚öôÔ∏è Settings', callback_data: 'main_settings' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, successMsg, successOpts);
      
//     } catch (err) {
//       console.error('Error uploading photo:', err);
//       delete userStates[telegramId];
//       bot.sendMessage(chatId, '‚ùå Failed to upload your photo. Please try again later.\n\nMake sure the image is clear and not too large.');
//     }
//   }
  
//   // Check if user is in story posting mode (existing functionality)
//   else if (userStates[telegramId] && userStates[telegramId].awaitingStory) {
//     try {
//       // Get the highest resolution photo
//       const photo = msg.photo[msg.photo.length - 1];
//       const fileId = photo.file_id;
//       const filePath = await bot.getFileLink(fileId);
      
//       // Post story to backend
//       const response = await axios.post(`${API_BASE}/stories/post/${telegramId}`, {
//         mediaUrl: filePath,
//         type: 'photo',
//         caption: msg.caption || '',
//         duration: 24 * 60 * 60 * 1000 // 24 hours in milliseconds
//       });
      
//       // Clear user state
//       delete userStates[telegramId];
      
//       // Send success message
//       const successMsg = `üì∏ **STORY POSTED!** üì∏\n\n` +
//         `‚úÖ Your story is now live for 24 hours!\n\n` +
//         `üìä **Track Performance:**\n` +
//         `‚Ä¢ Use /stories to view analytics\n` +
//         `‚Ä¢ See who viewed your story\n` +
//         `‚Ä¢ Post more stories to stay active\n\n` +
//         `üí° **Pro Tip:** Regular stories get more profile visits!`;

//       const storyOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üìä View Analytics', callback_data: 'story_analytics' },
//               { text: 'üì∏ Post Another', callback_data: 'post_story' }
//             ],
//             [
//               { text: 'üëÄ View Stories', callback_data: 'view_stories' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, successMsg, storyOpts);
      
//     } catch (err) {
//       console.error('Error posting story:', err);
//       delete userStates[telegramId];
//       bot.sendMessage(chatId, '‚ùå Failed to post your story. Please try again later.');
//     }
//   }
// });

// // Callback query handlers
// bot.on('callback_query', async (callbackQuery) => {
//   const message = callbackQuery.message;
//   const chatId = message.chat.id;
//   const telegramId = callbackQuery.from.id;
//   const data = callbackQuery.data;

//   if (data.startsWith('purchase_coins_')) {
//     const packageId = data.split('_')[2];
//     try {
//         const response = await axios.post(`${API_BASE}/coins/purchase`, {
//             telegramId: telegramId,
//             packageId: packageId
//         });
//         const data = response.data;
//         bot.sendMessage(chatId, `You have successfully purchased ${data.coins} coins. Your new balance is ${data.newBalance}.`);
//     } catch (error) {
//         console.error('Failed to process coin purchase:', error);
//         bot.sendMessage(chatId, 'Sorry, there was an error processing your purchase. Please try again later.');
//     }
//     bot.answerCallbackQuery(callbackQuery.id);
//     return;
//   }

//   try {
//     // Like/Pass/SuperLike handlers
//     if (data.startsWith('like_')) {
//       const targetId = data.split('_')[1];
//       await axios.post(`${API_BASE}/like`, { telegramId, targetId });
      
//       bot.editMessageReplyMarkup({}, {
//         chat_id: chatId,
//         message_id: message.message_id
//       });
      
//       bot.sendMessage(chatId, '‚ù§Ô∏è You liked this profile! Use /browse to see more.');
      
//     } else if (data.startsWith('pass_')) {
//       const targetId = data.split('_')[1];
//       await axios.post(`${API_BASE}/pass`, { telegramId, targetId });
      
//       bot.editMessageReplyMarkup({}, {
//         chat_id: chatId,
//         message_id: message.message_id
//       });
      
//       bot.sendMessage(chatId, 'üëé You passed on this profile. Use /browse to see more.');
      
//     } else if (data.startsWith('superlike_')) {
//       const targetId = data.split('_')[1];
//       await axios.post(`${API_BASE}/superlike`, { telegramId, targetId });
      
//       bot.editMessageReplyMarkup({}, {
//         chat_id: chatId,
//         message_id: message.message_id
//       });
      
//       bot.sendMessage(chatId, '‚≠ê You super liked this profile! They\'ll be notified.');
      
//     } else if (data.startsWith('gift_')) {
//       const targetId = data.split('_')[1];
//       // Show comprehensive gift selection menu
//       const giftOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üåπ Rose (10 coins)', callback_data: `send_gift_rose_${targetId}` },
//               { text: 'üíé Diamond (50 coins)', callback_data: `send_gift_diamond_${targetId}` }
//             ],
//             [
//               { text: 'üéÅ Gift Box (25 coins)', callback_data: `send_gift_box_${targetId}` },
//               { text: 'üç´ Chocolate (15 coins)', callback_data: `send_gift_chocolate_${targetId}` }
//             ],
//             [
//               { text: 'üå∫ Bouquet (30 coins)', callback_data: `send_gift_bouquet_${targetId}` },
//               { text: '‚≠ê Star (40 coins)', callback_data: `send_gift_star_${targetId}` }
//             ],
//             [
//               { text: '‚ùå Cancel', callback_data: 'cancel_gift' }
//             ]
//           ]
//         }
//       };
      
//       bot.sendMessage(chatId, 'üéÅ Choose a gift to send:', giftOpts);
      
//     } else if (data.startsWith('send_gift_')) {
//       const parts = data.split('_');
//       const giftType = parts[2];
//       const targetId = parts[3];
      
//       try {
//         const res = await axios.post(`${API_BASE}/gifts/send`, { 
//           telegramId, 
//           targetId, 
//           giftType 
//         });
        
//         const giftInfo = res.data;
//         const successMsg = `üéÅ **Gift Sent Successfully!** üéÅ\n\n` +
//           `${giftInfo.giftEmoji} You sent a **${giftInfo.giftName}** to ${giftInfo.recipientName || 'someone special'}!\n\n` +
//           `üí∞ Cost: ${giftInfo.cost} coins\n` +
//           `üí∞ Remaining Balance: ${giftInfo.remainingBalance} coins\n\n` +
//           `They'll be notified about your thoughtful gift! üíï`;
        
//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üéÅ Send Another Gift', callback_data: 'gifts_send' },
//                 { text: 'üí¨ Start Conversation', callback_data: `message_${targetId}` }
//               ],
//               [
//                 { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//               ]
//             ]
//           }
//         };
        
//         bot.sendMessage(chatId, successMsg, opts);
        
//       } catch (err) {
//         console.error('Gift sending error:', err.response?.data || err.message);
        
//         if (err.response?.status === 400) {
//           const errorMsg = err.response.data.message || 'Failed to send gift';
//           bot.sendMessage(chatId, `‚ùå ${errorMsg}`);
//         } else if (err.response?.status === 402) {
//           bot.sendMessage(chatId, 'üí∞ Insufficient coins! Use /coins to purchase more coins.');
//         } else {
//           bot.sendMessage(chatId, '‚ùå Failed to send gift. Please try again later.');
//         }
//       }
      
//     } else if (data === 'cancel_gift' || data === 'gifts_cancel') {
//       bot.sendMessage(chatId, '‚ùå Gift sending cancelled.');
      
//     } else if (data === 'buy_coins') {
//       // Show coin packages
//       const coinOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'Starter Pack (1000 coins - $4.99)', callback_data: 'buy_coins_starter' }
//             ],
//             [
//               { text: 'Popular Pack (5500 coins - $19.99)', callback_data: 'buy_coins_popular' }
//             ],
//             [
//               { text: 'Premium Pack (14000 coins - $39.99)', callback_data: 'buy_coins_premium' }
//             ],
//             [
//               { text: 'Ultimate Pack (38000 coins - $79.99)', callback_data: 'buy_coins_ultimate' }
//             ]
//           ]
//         }
//       };
      
//       bot.sendMessage(chatId, 'üí∞ Choose a coin package:', coinOpts);
      
//     } else if (data === 'search_gender') {
//       const genderOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üë® Men', callback_data: 'set_gender_male' },
//               { text: 'üë© Women', callback_data: 'set_gender_female' }
//             ],
//             [
//               { text: 'üåà Everyone', callback_data: 'set_gender_any' },
//               { text: '‚ùå Cancel', callback_data: 'search_cancel' }
//             ]
//           ]
//         }
//       };
//       bot.sendMessage(chatId, 'üë• Who would you like to see?', genderOpts);
      
//     } else if (data.startsWith('set_gender_')) {
//       const gender = data.split('_')[2];
//       await axios.post(`${API_BASE}/search-settings/${telegramId}`, { genderPreference: gender });
//       bot.sendMessage(chatId, `‚úÖ Gender preference updated to: ${gender === 'any' ? 'Everyone' : gender}`);
      
//     } else if (data === 'search_age') {
//       const ageOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: '18-25', callback_data: 'set_age_18_25' },
//               { text: '26-35', callback_data: 'set_age_26_35' }
//             ],
//             [
//               { text: '36-45', callback_data: 'set_age_36_45' },
//               { text: '46+', callback_data: 'set_age_46_99' }
//             ],
//             [
//               { text: 'üåê Any Age', callback_data: 'set_age_18_99' },
//               { text: '‚ùå Cancel', callback_data: 'search_cancel' }
//             ]
//           ]
//         }
//       };
//       bot.sendMessage(chatId, 'üéÇ Select age range:', ageOpts);
      
//     } else if (data.startsWith('set_age_')) {
//       const parts = data.split('_');
//       const minAge = parseInt(parts[2]);
//       const maxAge = parseInt(parts[3]);
//       await axios.post(`${API_BASE}/search-settings/${telegramId}`, { minAge, maxAge });
//       bot.sendMessage(chatId, `‚úÖ Age range updated to: ${minAge}-${maxAge}`);
      
//     } else if (data === 'search_distance') {
//       const distanceOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: '5 km', callback_data: 'set_distance_5' },
//               { text: '10 km', callback_data: 'set_distance_10' }
//             ],
//             [
//               { text: '25 km', callback_data: 'set_distance_25' },
//               { text: '50 km', callback_data: 'set_distance_50' }
//             ],
//             [
//               { text: 'üåç Unlimited', callback_data: 'set_distance_unlimited' },
//               { text: '‚ùå Cancel', callback_data: 'search_cancel' }
//             ]
//           ]
//         }
//       };
//       bot.sendMessage(chatId, 'üìç Select maximum distance:', distanceOpts);
      
//     } else if (data.startsWith('set_distance_')) {
//       const distance = data.split('_')[2];
//       const maxDistance = distance === 'unlimited' ? null : parseInt(distance);
//       await axios.post(`${API_BASE}/search-settings/${telegramId}`, { maxDistance });
//       bot.sendMessage(chatId, `‚úÖ Distance updated to: ${distance === 'unlimited' ? 'Unlimited' : distance + ' km'}`);
      
//     } else if (data === 'search_location') {
//       const locationOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üè† Current City', callback_data: 'set_location_current' },
//               { text: 'üåÜ Nearby Cities', callback_data: 'set_location_nearby' }
//             ],
//             [
//               { text: 'üåç Anywhere', callback_data: 'set_location_anywhere' },
//               { text: '‚ùå Cancel', callback_data: 'search_cancel' }
//             ]
//           ]
//         }
//       };
//       bot.sendMessage(chatId, 'üåç Choose your location preference:', locationOpts);
      
//     } else if (data.startsWith('set_location_')) {
//       const locationType = data.split('_')[2];
//       let locationPreference;
      
//       switch(locationType) {
//         case 'current': locationPreference = 'Current City'; break;
//         case 'nearby': locationPreference = 'Nearby Cities'; break;
//         case 'anywhere': locationPreference = 'Anywhere'; break;
//         default: locationPreference = 'Any';
//       }
      
//       await axios.post(`${API_BASE}/search-settings/${telegramId}`, { locationPreference });
//       bot.sendMessage(chatId, `‚úÖ Location preference updated to: ${locationPreference}`);
      
//     } else if (data === 'search_reset') {
//       await axios.delete(`${API_BASE}/search-settings/${telegramId}`);
//       bot.sendMessage(chatId, 'üîÑ Search settings reset to default!');
      
//     } else if (data === 'search_done' || data === 'search_cancel') {
//       bot.sendMessage(chatId, '‚úÖ Search settings updated!');
      
//     } else if (data === 'gifts_send') {
//       // Show recent matches to send gifts to
//       try {
//         const res = await axios.get(`${API_BASE}/matches/${telegramId}`);
//         const matches = res.data;
        
//         if (!matches.length) {
//           return bot.sendMessage(chatId, 'üíî You need matches to send gifts!\n\nUse /browse to find people and match with them first.');
//         }
        
//         let matchButtons = matches.slice(0, 5).map(match => ([
//           { text: `üéÅ ${match.name || 'Anonymous'}`, callback_data: `gift_to_${match.telegramId}` }
//         ]));
        
//         matchButtons.push([{ text: '‚ùå Cancel', callback_data: 'gifts_cancel' }]);
        
//         bot.sendMessage(chatId, 'üë• Choose someone to send a gift to:', {
//           reply_markup: { inline_keyboard: matchButtons }
//         });
        
//       } catch (err) {
//         bot.sendMessage(chatId, '‚ùå Failed to load your matches. Please try again later.');
//       }
      
//     } else if (data.startsWith('gift_to_')) {
//       const targetId = data.split('_')[2];
      
//       const giftOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üåπ Rose (10 coins)', callback_data: `send_gift_rose_${targetId}` },
//               { text: 'üíé Diamond (50 coins)', callback_data: `send_gift_diamond_${targetId}` }
//             ],
//             [
//               { text: 'üéÅ Gift Box (25 coins)', callback_data: `send_gift_box_${targetId}` },
//               { text: 'üç´ Chocolate (15 coins)', callback_data: `send_gift_chocolate_${targetId}` }
//             ],
//             [
//               { text: 'üå∫ Bouquet (30 coins)', callback_data: `send_gift_bouquet_${targetId}` },
//               { text: '‚≠ê Star (40 coins)', callback_data: `send_gift_star_${targetId}` }
//             ],
//             [
//               { text: '‚ùå Cancel', callback_data: 'gifts_cancel' }
//             ]
//           ]
//         }
//       };
      
//       bot.sendMessage(chatId, 'üéÅ Choose a gift to send:', giftOpts);
      
//     } else if (data === 'gifts_shop') {
//       const shopMsg = `üõçÔ∏è **GIFT SHOP** üõçÔ∏è\n\n` +
//         `Available gifts and their meanings:\n\n` +
//         `üåπ **Rose** (10 coins)\n` +
//         `‚Ä¢ Classic romantic gesture\n` +
//         `‚Ä¢ Shows interest and appreciation\n\n` +
//         `üíé **Diamond** (50 coins)\n` +
//         `‚Ä¢ Premium luxury gift\n` +
//         `‚Ä¢ Shows serious romantic interest\n\n` +
//         `üéÅ **Gift Box** (25 coins)\n` +
//         `‚Ä¢ Mystery surprise gift\n` +
//         `‚Ä¢ Fun and playful gesture\n\n` +
//         `üç´ **Chocolate** (15 coins)\n` +
//         `‚Ä¢ Sweet and thoughtful\n` +
//         `‚Ä¢ Perfect for new connections\n\n` +
//         `üå∫ **Bouquet** (30 coins)\n` +
//         `‚Ä¢ Beautiful flower arrangement\n` +
//         `‚Ä¢ Shows deep appreciation\n\n` +
//         `‚≠ê **Star** (40 coins)\n` +
//         `‚Ä¢ You're a star gift\n` +
//         `‚Ä¢ Shows admiration and respect`;
      
//       const shopOpts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üéÅ Send Gift', callback_data: 'gifts_send' },
//               { text: 'üí∞ Buy Coins', callback_data: 'buy_coins' }
//             ],
//             [
//               { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//             ]
//           ]
//         }
//       };
      
//       bot.sendMessage(chatId, shopMsg, shopOpts);
      
//     } else if (data === 'gifts_received') {
//       try {
//         const res = await axios.get(`${API_BASE}/gifts/received/${telegramId}`);
//         const receivedGifts = res.data;
        
//         console.log('Received gifts response:', receivedGifts); // Debug log
        
//         // Handle different response formats
//         const gifts = Array.isArray(receivedGifts) ? receivedGifts : (receivedGifts.gifts || []);
        
//         if (!gifts || gifts.length === 0) {
//           return bot.sendMessage(chatId, 'üì• No gifts received yet.\n\nWhen someone sends you a gift, it will appear here!');
//         }
        
//         let giftsText = `üì• **RECEIVED GIFTS** üì•\n\n`;
//         gifts.slice(0, 10).forEach((gift, index) => {
//           const timeAgo = gift.sentAt ? new Date(gift.sentAt).toLocaleDateString() : 'Unknown';
//           const giftEmoji = gift.giftEmoji || gift.emoji || 'üéÅ';
//           const giftName = gift.giftName || gift.name || gift.type || 'Gift';
//           const senderName = gift.senderName || gift.sender?.name || gift.fromName || 'Anonymous';
          
//           giftsText += `${giftEmoji} **${giftName}**\n`;
//           giftsText += `From: ${senderName}\n`;
//           giftsText += `Date: ${timeAgo}\n`;
//           if (gift.message || gift.note) giftsText += `Message: "${gift.message || gift.note}"\n`;
//           giftsText += `\n`;
//         });
        
//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üíå Send Thank You', callback_data: 'gifts_thank_you' },
//                 { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//               ]
//             ]
//           }
//         };
        
//         bot.sendMessage(chatId, giftsText, opts);
        
//       } catch (err) {
//         console.error('Received gifts error:', err.response?.data || err.message);
//         const errorMsg = err.response?.status === 404 ? 
//           'üì• No gifts received yet.\n\nWhen someone sends you a gift, it will appear here!' :
//           '‚ùå Failed to load received gifts. Please try again later.';
//         bot.sendMessage(chatId, errorMsg);
//       }
      
//     } else if (data === 'gifts_sent') {
//       try {
//         const res = await axios.get(`${API_BASE}/gifts/sent/${telegramId}`);
//         const sentGifts = res.data;
        
//         if (!sentGifts.length) {
//           return bot.sendMessage(chatId, 'üì§ No gifts sent yet.\n\nUse "üéÅ Send Gift" to send your first gift!');
//         }
        
//         let giftsText = `üì§ **SENT GIFTS** üì§\n\n`;
//         sentGifts.slice(0, 10).forEach((gift, index) => {
//           const timeAgo = new Date(gift.sentAt).toLocaleDateString();
//           giftsText += `${gift.giftEmoji} **${gift.giftName}**\n`;
//           giftsText += `To: ${gift.recipientName || 'Anonymous'}\n`;
//           giftsText += `Date: ${timeAgo}\n`;
//           giftsText += `Cost: ${gift.cost} coins\n\n`;
//         });
        
//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üéÅ Send Another Gift', callback_data: 'gifts_send' },
//                 { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//               ]
//             ]
//           }
//         };
        
//         bot.sendMessage(chatId, giftsText, opts);
        
//       } catch (err) {
//         bot.sendMessage(chatId, '‚ùå Failed to load sent gifts. Please try again later.');
//       }
      
//     } else if (data === 'gifts_analytics') {
//       try {
//         console.log(`Fetching gift analytics for user: ${telegramId}`);
//         const res = await axios.get(`${API_BASE}/gifts/analytics/${telegramId}`);
//         console.log('Gift analytics API response status:', res.status);
//         console.log('Gift analytics response data:', JSON.stringify(res.data, null, 2));
        
//         const analytics = res.data;
        
//         // Handle different response formats
//         const stats = analytics.stats || analytics.data || analytics || {};
        
//         console.log('Processed stats object:', JSON.stringify(stats, null, 2));
        
//         // Create analytics message with more robust data handling
//         const totalSent = parseInt(stats.totalSent || stats.sent || stats.giftsSent || 0);
//         const totalReceived = parseInt(stats.totalReceived || stats.received || stats.giftsReceived || 0);
//         const coinsSpent = parseInt(stats.coinsSpent || stats.totalSpent || stats.spent || 0);
//         const mostSentGift = stats.mostSentGift || stats.favoriteGift || stats.topSent || 'None';
//         const mostReceivedGift = stats.mostReceivedGift || stats.topReceived || stats.favoriteReceived || 'None';
//         const monthSent = parseInt(stats.monthSent || stats.thisMonthSent || stats.currentMonthSent || 0);
//         const monthReceived = parseInt(stats.monthReceived || stats.thisMonthReceived || stats.currentMonthReceived || 0);
//         const responseRate = parseFloat(stats.responseRate || stats.response || 0).toFixed(1);
//         const thankYouRate = parseFloat(stats.thankYouRate || stats.thankYou || stats.thanks || 0).toFixed(1);
        
//         const analyticsMsg = `üìä **GIFT ANALYTICS** üìä\n\n` +
//           `üìà **Your Gift Statistics:**\n` +
//           `‚Ä¢ Total Gifts Sent: ${totalSent}\n` +
//           `‚Ä¢ Total Gifts Received: ${totalReceived}\n` +
//           `‚Ä¢ Coins Spent on Gifts: ${coinsSpent}\n` +
//           `‚Ä¢ Most Popular Gift Sent: ${mostSentGift}\n` +
//           `‚Ä¢ Most Received Gift: ${mostReceivedGift}\n\n` +
//           `üéØ **This Month:**\n` +
//           `‚Ä¢ Gifts Sent: ${monthSent}\n` +
//           `‚Ä¢ Gifts Received: ${monthReceived}\n\n` +
//           `üíù **Gift Success Rate:**\n` +
//           `‚Ä¢ Response Rate: ${responseRate}%\n` +
//           `‚Ä¢ Thank You Rate: ${thankYouRate}%`;
        
//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üéÅ Send More Gifts', callback_data: 'gifts_send' },
//                 { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//               ]
//             ]
//           }
//         };
        
//         console.log('Sending analytics message to user');
//         bot.sendMessage(chatId, analyticsMsg, opts);
        
//       } catch (err) {
//         console.error('Gift analytics error details:');
//         console.error('Error status:', err.response?.status);
//         console.error('Error data:', err.response?.data);
//         console.error('Error message:', err.message);
//         console.error('Full error:', err);
        
//         // Try to get basic analytics from other endpoints if main analytics fails
//         let fallbackAnalytics = null;
//         try {
//           console.log('Attempting to get fallback analytics from other endpoints...');
          
//           // Try to get sent and received gifts to calculate basic stats
//           const [sentRes, receivedRes] = await Promise.allSettled([
//             axios.get(`${API_BASE}/gifts/sent/${telegramId}`),
//             axios.get(`${API_BASE}/gifts/received/${telegramId}`)
//           ]);
          
//           const sentGifts = sentRes.status === 'fulfilled' ? (sentRes.value.data || []) : [];
//           const receivedGifts = receivedRes.status === 'fulfilled' ? (receivedRes.value.data || []) : [];
          
//           console.log('Fallback data - Sent gifts:', sentGifts.length, 'Received gifts:', receivedGifts.length);
          
//           // Calculate basic statistics
//           const totalSent = Array.isArray(sentGifts) ? sentGifts.length : 0;
//           const totalReceived = Array.isArray(receivedGifts) ? receivedGifts.length : 0;
//           const coinsSpent = Array.isArray(sentGifts) ? sentGifts.reduce((sum, gift) => sum + (gift.cost || 0), 0) : 0;
          
//           // Get most popular gift sent
//           const giftCounts = {};
//           if (Array.isArray(sentGifts)) {
//             sentGifts.forEach(gift => {
//               const giftName = gift.giftName || gift.type || 'Unknown';
//               giftCounts[giftName] = (giftCounts[giftName] || 0) + 1;
//             });
//           }
//           const mostSentGift = Object.keys(giftCounts).length > 0 ? 
//             Object.keys(giftCounts).reduce((a, b) => giftCounts[a] > giftCounts[b] ? a : b) : 'None';
          
//           fallbackAnalytics = `üìä **GIFT ANALYTICS** üìä\n\n` +
//             `üìà **Your Gift Statistics:**\n` +
//             `‚Ä¢ Total Gifts Sent: ${totalSent}\n` +
//             `‚Ä¢ Total Gifts Received: ${totalReceived}\n` +
//             `‚Ä¢ Coins Spent on Gifts: ${coinsSpent}\n` +
//             `‚Ä¢ Most Popular Gift Sent: ${mostSentGift}\n` +
//             `‚Ä¢ Most Received Gift: N/A\n\n` +
//             `üéØ **This Month:**\n` +
//             `‚Ä¢ Gifts Sent: ${totalSent}\n` +
//             `‚Ä¢ Gifts Received: ${totalReceived}\n\n` +
//             `üíù **Gift Success Rate:**\n` +
//             `‚Ä¢ Response Rate: N/A\n` +
//             `‚Ä¢ Thank You Rate: N/A\n\n` +
//             `üìù *Analytics calculated from available data*`;
            
//         } catch (fallbackErr) {
//           console.error('Fallback analytics also failed:', fallbackErr.message);
//         }
        
//         // Use fallback analytics or default message
//         const defaultAnalytics = fallbackAnalytics || (
//           `üìä **GIFT ANALYTICS** üìä\n\n` +
//           `üìà **Your Gift Statistics:**\n` +
//           `‚Ä¢ Total Gifts Sent: 0\n` +
//           `‚Ä¢ Total Gifts Received: 0\n` +
//           `‚Ä¢ Coins Spent on Gifts: 0\n` +
//           `‚Ä¢ Most Popular Gift Sent: None\n` +
//           `‚Ä¢ Most Received Gift: None\n\n` +
//           `üéØ **This Month:**\n` +
//           `‚Ä¢ Gifts Sent: 0\n` +
//           `‚Ä¢ Gifts Received: 0\n\n` +
//           `üíù **Gift Success Rate:**\n` +
//           `‚Ä¢ Response Rate: 0%\n` +
//           `‚Ä¢ Thank You Rate: 0%\n\n` +
//           `Start sending gifts to build your analytics! üéÅ`
//         );
        
//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üéÅ Start Sending Gifts', callback_data: 'gifts_send' },
//                 { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//               ]
//             ]
//           }
//         };
        
//         bot.sendMessage(chatId, defaultAnalytics, opts);
//       }
      
//     } else if (data === 'gifts_help') {
//       const helpMsg = `‚ùì **GIFT GUIDE** ‚ùì\n\n` +
//         `üéÅ **How Gifts Work:**\n` +
//         `‚Ä¢ Send virtual gifts to show interest\n` +
//         `‚Ä¢ Each gift costs coins\n` +
//         `‚Ä¢ Recipients get notified immediately\n` +
//         `‚Ä¢ Gifts can lead to conversations\n\n` +
//         `üí° **Gift Tips:**\n` +
//         `‚Ä¢ Start with simple gifts like roses\n` +
//         `‚Ä¢ Premium gifts show serious interest\n` +
//         `‚Ä¢ Add personal messages when possible\n` +
//         `‚Ä¢ Timing matters - send when they're active\n\n` +
//         `üåü **Best Practices:**\n` +
//         `‚Ä¢ Don't spam gifts to the same person\n` +
//         `‚Ä¢ Choose gifts that match your relationship\n` +
//         `‚Ä¢ Be genuine and thoughtful\n` +
//         `‚Ä¢ Respond to gifts you receive`;
      
//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üéÅ Start Sending Gifts', callback_data: 'gifts_send' },
//               { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//             ]
//           ]
//         }
//       };
      
//       bot.sendMessage(chatId, helpMsg, opts);
      
//     } else if (data === 'gifts_back') {
//       // Re-trigger the gifts command by simulating the command
//       try {
//         const res = await axios.get(`${API_BASE}/gifts/${telegramId}`);
//         const { sentGifts, receivedGifts, giftStats, coinBalance } = res.data;

//         const giftsMsg = `üéÅ **GIFT CENTER** üéÅ\n\n` +
//           `üí∞ Your Coins: ${coinBalance || 0}\n\n` +
//           `üìä **Gift Statistics:**\n` +
//           `‚Ä¢ Gifts Sent: ${giftStats?.totalSent || 0}\n` +
//           `‚Ä¢ Gifts Received: ${giftStats?.totalReceived || 0}\n` +
//           `‚Ä¢ Favorite Gift: ${giftStats?.favoriteGift || 'None'}\n\n` +
//           `Choose what you'd like to do:`;

//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üéÅ Send Gift', callback_data: 'gifts_send' },
//                 { text: 'üì• Received Gifts', callback_data: 'gifts_received' }
//               ],
//               [
//                 { text: 'üì§ Sent Gifts', callback_data: 'gifts_sent' },
//                 { text: 'üõçÔ∏è Gift Shop', callback_data: 'gifts_shop' }
//               ],
//               [
//                 { text: 'üìä Gift Analytics', callback_data: 'gifts_analytics' },
//                 { text: '‚ùì Gift Guide', callback_data: 'gifts_help' }
//               ]
//             ]
//           }
//         };

//         bot.sendMessage(chatId, giftsMsg, opts);

//       } catch (err) {
//         // Show default gifts menu if API fails
//         const defaultMsg = `üéÅ **GIFT CENTER** üéÅ\n\n` +
//           `Send virtual gifts to show someone you care!\n\n` +
//           `Choose what you'd like to do:`;

//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üéÅ Send Gift', callback_data: 'gifts_send' },
//                 { text: 'üõçÔ∏è Gift Shop', callback_data: 'gifts_shop' }
//               ],
//               [
//                 { text: 'üí∞ Buy Coins', callback_data: 'buy_coins' },
//                 { text: '‚ùì Gift Guide', callback_data: 'gifts_help' }
//               ]
//             ]
//           }
//         };

//         bot.sendMessage(chatId, defaultMsg, opts);
//       }
      
//     } else if (data === 'gifts_cancel') {
//       bot.sendMessage(chatId, '‚ùå Gift sending cancelled.');
      
//     } else if (data === 'gifts_thank_you') {
//       const thankYouMsg = `üíå **SEND THANK YOU** üíå\n\n` +
//         `Show appreciation for the gifts you've received!\n\n` +
//         `Choose how you'd like to thank your admirers:`;
      
//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üíï Send Heart', callback_data: 'send_thank_heart' },
//               { text: 'üåπ Send Rose Back', callback_data: 'send_thank_rose' }
//             ],
//             [
//               { text: 'üí¨ Send Message', callback_data: 'send_thank_message' },
//               { text: 'üéÅ Send Gift Back', callback_data: 'gifts_send' }
//             ],
//             [
//               { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//             ]
//           ]
//         }
//       };
      
//       bot.sendMessage(chatId, thankYouMsg, opts);
      
//     } else if (data.startsWith('send_thank_')) {
//       const thankType = data.split('_')[2];
//       let message = '';
      
//       switch(thankType) {
//         case 'heart':
//           message = 'üíï Thank you hearts sent to recent gift senders!';
//           break;
//         case 'rose':
//           message = 'üåπ Thank you roses sent to recent gift senders!';
//           break;
//         case 'message':
//           message = 'üí¨ Thank you messages sent to recent gift senders!';
//           break;
//         default:
//           message = 'üíå Thank you sent!';
//       }
      
//       try {
//         await axios.post(`${API_BASE}/gifts/thank-you/${telegramId}`, { thankType });
//         bot.sendMessage(chatId, message);
//       } catch (err) {
//         bot.sendMessage(chatId, '‚ùå Failed to send thank you. Please try again later.');
//       }
      
//     } else if (data.startsWith('message_')) {
//       const targetId = data.split('_')[1];
      
//       const messageMsg = `üí¨ **START CONVERSATION** üí¨\n\n` +
//         `Great! You can now start a conversation with this person.\n\n` +
//         `üí° **Conversation Tips:**\n` +
//         `‚Ä¢ Be genuine and friendly\n` +
//         `‚Ä¢ Ask about their interests\n` +
//         `‚Ä¢ Reference the gift you sent\n` +
//         `‚Ä¢ Keep it light and fun\n\n` +
//         `Use the messaging feature in your Telegram to send them a direct message!`;
      
//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üéÅ Send Another Gift', callback_data: `gift_${targetId}` },
//               { text: 'üëÄ View Profile', callback_data: `profile_${targetId}` }
//             ],
//             [
//               { text: 'üîô Back to Gifts', callback_data: 'gifts_back' }
//             ]
//           ]
//         }
//       };
      
//       bot.sendMessage(chatId, messageMsg, opts);
      
//     } else if (data === 'send_gift') {
//       // Redirect to gifts_send for sending gifts
//       // This is triggered from coin purchase success buttons
//       try {
//         const res = await axios.get(`${API_BASE}/matches/${telegramId}`);
//         const matches = res.data;
        
//         if (!matches.length) {
//           return bot.sendMessage(chatId, 'üíî You need matches to send gifts!\n\nUse /browse to find people and match with them first.');
//         }
        
//         let matchButtons = matches.slice(0, 5).map(match => ([
//           { text: `üéÅ ${match.name || 'Anonymous'}`, callback_data: `gift_to_${match.telegramId}` }
//         ]));
        
//         matchButtons.push([{ text: '‚ùå Cancel', callback_data: 'gifts_cancel' }]);
        
//         bot.sendMessage(chatId, 'üë• Choose someone to send a gift to:', {
//           reply_markup: { inline_keyboard: matchButtons }
//         });
        
//       } catch (err) {
//         bot.sendMessage(chatId, '‚ùå Failed to load your matches. Please try again later.');
//       }
      
//     } else if (data === 'priority_boost') {
//       // Handle priority boost purchase
//       try {
//         const res = await axios.post(`${API_BASE}/priority/purchase/${telegramId}`);
//         const boostInfo = res.data;
        
//         const successMsg = `üöÄ **PRIORITY BOOST ACTIVATED!** üöÄ\n\n` +
//           `‚≠ê Your profile will appear first in search results!\n` +
//           `‚è∞ Duration: ${boostInfo.duration || '24 hours'}\n` +
//           `üí∞ Cost: ${boostInfo.cost || 50} coins\n\n` +
//           `Get ready for more profile views and matches! üî•`;
        
//         bot.sendMessage(chatId, successMsg);
//       } catch (err) {
//         if (err.response?.status === 402) {
//           bot.sendMessage(chatId, 'üí∞ Insufficient coins for priority boost! Use /coins to purchase more.');
//         } else {
//           bot.sendMessage(chatId, '‚ùå Failed to activate priority boost. Please try again later.');
//         }
//       }
      
//     } else if (data === 'settings_search') {
//       try {
//         const res = await axios.get(`${API_BASE}/search-settings/${telegramId}`);
//         const settings = res.data;

//         const searchMsg = `üîç **SEARCH PREFERENCES** üîç\n\n` +
//           `üìä **Current Settings:**\n` +
//           `‚Ä¢ Age Range: ${settings.ageMin || 18}-${settings.ageMax || 35} years\n` +
//           `‚Ä¢ Max Distance: ${settings.maxDistance || 50} km\n` +
//           `‚Ä¢ Gender: ${settings.genderPreference || 'Any'}\n` +
//           `‚Ä¢ Location: ${settings.locationPreference || 'Any'}\n\n` +
//           `‚öôÔ∏è **Customize your search to find better matches!**`;

//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üéÇ Age Range', callback_data: 'search_age' },
//                 { text: 'üìè Distance', callback_data: 'search_distance' }
//               ],
//               [
//                 { text: 'üë• Gender', callback_data: 'search_gender' },
//                 { text: 'üìç Location', callback_data: 'search_location' }
//               ],
//               [
//                 { text: 'üîÑ Reset to Default', callback_data: 'search_reset' }
//               ],
//               [
//                 { text: 'üîô Back to Settings', callback_data: 'main_settings' }
//               ]
//             ]
//           }
//         };

//         bot.sendMessage(chatId, searchMsg, opts);
//       } catch (err) {
//         console.error('Search settings error:', err.response?.data || err.message);
//         bot.sendMessage(chatId, '‚ùå Failed to load search settings. Please try again later.');
//       }
      
//     } else if (data === 'settings_premium') {
//       const premiumMsg = `üíé **PREMIUM FEATURES** üíé\n\n` +
//         `Unlock the full potential of Kisu1bot!\n\n` +
//         `üëë **VIP Membership**\n` +
//         `‚Ä¢ Unlimited swipes\n` +
//         `‚Ä¢ See who liked you\n` +
//         `‚Ä¢ Priority matching\n` +
//         `‚Ä¢ Ad-free experience\n\n` +
//         `üí∞ **Coins & Purchases**\n` +
//         `‚Ä¢ Buy coins for premium features\n` +
//         `‚Ä¢ Send virtual gifts\n` +
//         `‚Ä¢ Boost your profile\n\n` +
//         `Choose what you'd like to manage:`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üëë VIP Membership', callback_data: 'manage_vip' },
//               { text: 'üí∞ Buy Coins', callback_data: 'buy_coins' }
//             ],
//             [
//               { text: '‚ö°Ô∏è Priority Boost', callback_data: 'priority_boost' },
//               { text: 'üéÅ Gift Center', callback_data: 'gifts_back' }
//             ],
//             [
//               { text: 'üîô Back to Settings', callback_data: 'main_settings' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, premiumMsg, opts);
      
//     } else if (data === 'settings_notifications') {
//       const notifMsg = `üîî **NOTIFICATION SETTINGS** üîî\n\n` +
//         `Manage your notification preferences:\n\n` +
//         `üì± **Push Notifications**\n` +
//         `‚Ä¢ New matches\n` +
//         `‚Ä¢ New messages\n` +
//         `‚Ä¢ Profile likes\n` +
//         `‚Ä¢ Gifts received\n\n` +
//         `üìß **Email Notifications**\n` +
//         `‚Ä¢ Weekly match summary\n` +
//         `‚Ä¢ Special offers\n` +
//         `‚Ä¢ Account updates\n\n` +
//         `‚öôÔ∏è Customize your notification experience:`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üì± Push Settings', callback_data: 'notif_push' },
//               { text: 'üìß Email Settings', callback_data: 'notif_email' }
//             ],
//             [
//               { text: 'üîï Disable All', callback_data: 'notif_disable' },
//               { text: 'üîî Enable All', callback_data: 'notif_enable' }
//             ],
//             [
//               { text: 'üîô Back to Settings', callback_data: 'main_settings' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, notifMsg, opts);
      
//     } else if (data === 'settings_privacy') {
//       const privacyMsg = `üîí **PRIVACY & SAFETY** üîí\n\n` +
//         `Control your privacy and safety settings:\n\n` +
//         `üëÄ **Profile Visibility**\n` +
//         `‚Ä¢ Who can see your profile\n` +
//         `‚Ä¢ Show online status\n` +
//         `‚Ä¢ Hide from specific users\n\n` +
//         `üõ°Ô∏è **Safety Features**\n` +
//         `‚Ä¢ Block and report users\n` +
//         `‚Ä¢ Content filtering\n` +
//         `‚Ä¢ Photo verification\n\n` +
//         `Manage your privacy preferences:`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üëÄ Visibility Settings', callback_data: 'privacy_visibility' },
//               { text: 'üö´ Blocked Users', callback_data: 'privacy_blocked' }
//             ],
//             [
//               { text: 'üì∏ Photo Privacy', callback_data: 'privacy_photos' },
//               { text: 'üõ°Ô∏è Safety Center', callback_data: 'safety_center' }
//             ],
//             [
//               { text: 'üîô Back to Settings', callback_data: 'main_settings' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, privacyMsg, opts);
      
//     } else if (data === 'settings_account') {
//       const accountMsg = `üõ†Ô∏è **ACCOUNT SETTINGS** üõ†Ô∏è\n\n` +
//         `Manage your account and data:\n\n` +
//         `üìä **Account Information**\n` +
//         `‚Ä¢ View account details\n` +
//         `‚Ä¢ Download your data\n` +
//         `‚Ä¢ Account statistics\n\n` +
//         `‚ö†Ô∏è **Account Actions**\n` +
//         `‚Ä¢ Deactivate account\n` +
//         `‚Ä¢ Delete account\n` +
//         `‚Ä¢ Data export\n\n` +
//         `Choose an account action:`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üìä Account Info', callback_data: 'account_info' },
//               { text: 'üì• Download Data', callback_data: 'download_data' }
//             ],
//             [
//               { text: '‚è∏Ô∏è Deactivate', callback_data: 'deactivate_account' },
//               { text: 'üóëÔ∏è Delete Account', callback_data: 'delete_account' }
//             ],
//             [
//               { text: 'üîô Back to Settings', callback_data: 'main_settings' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, accountMsg, opts);
      
//     } else if (data === 'settings_help') {
//       const helpMsg = `‚ùì **HELP & SUPPORT** ‚ùì\n\n` +
//         `Get help and support for Kisu1bot:\n\n` +
//         `üìö **Help Resources**\n` +
//         `‚Ä¢ User guide\n` +
//         `‚Ä¢ FAQ\n` +
//         `‚Ä¢ Video tutorials\n\n` +
//         `üí¨ **Contact Support**\n` +
//         `‚Ä¢ Report issues\n` +
//         `‚Ä¢ Feature requests\n` +
//         `‚Ä¢ General inquiries\n\n` +
//         `How can we help you?`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üìö User Guide', callback_data: 'help_guide' },
//               { text: '‚ùì FAQ', callback_data: 'help_faq' }
//             ],
//             [
//               { text: 'üêõ Report Bug', callback_data: 'report_bug' },
//               { text: 'üí° Feature Request', callback_data: 'feature_request' }
//             ],
//             [
//               { text: 'üìû Contact Support', callback_data: 'contact_support' },
//               { text: 'üîô Back to Settings', callback_data: 'main_settings' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, helpMsg, opts);
      
//     } else if (data === 'edit_name') {
//       await State.findOneAndUpdate({ telegramId }, { step: 'edit_name' }, { upsert: true });
//       bot.sendMessage(chatId, '‚úèÔ∏è EDIT NAME\n\nPlease send your new name as a message.\n\nüìù It will update immediately after you send it.\n\n‚ùå Send /cancel to abort.');
      
//     } else if (data === 'edit_age') {
//       await State.findOneAndUpdate({ telegramId }, { step: 'edit_age' }, { upsert: true });
//       bot.sendMessage(chatId, 'üéÇ EDIT AGE\n\nPlease send your new age as a number between 18 and 99.\n\n‚ùå Send /cancel to abort.');
      
//     } else if (data === 'edit_location') {
//       await State.findOneAndUpdate({ telegramId }, { step: 'edit_location' }, { upsert: true });
//       bot.sendMessage(chatId, 'üìç EDIT LOCATION\n\nPlease send your new location (e.g., USA).\n\n‚ùå Send /cancel to abort.');
      
//     } else if (data === 'edit_bio') {
//       await State.findOneAndUpdate({ telegramId }, { step: 'edit_bio' }, { upsert: true });
//       bot.sendMessage(chatId, 'üìù EDIT BIO\n\nPlease send your new bio/description (max ~300 chars).\n\nüí° Make it interesting and authentic!\n\n‚ùå Send /cancel to abort.');
      
//     } else if (data === 'manage_photos') {
//       const photoMsg = `üì∏ **MANAGE PHOTOS** üì∏\n\n` +
//         `Upload and manage your profile photos:\n\n` +
//         `üì± **Photo Tips:**\n` +
//         `‚Ä¢ Use high-quality, clear photos\n` +
//         `‚Ä¢ Show your face clearly\n` +
//         `‚Ä¢ Include variety (close-up, full body, activities)\n` +
//         `‚Ä¢ Avoid group photos as main photo\n\n` +
//         `üì§ **To add photos:** Send them directly to this chat\n` +
//         `üóëÔ∏è **To delete photos:** Use the buttons below`;

//       try {
//         const profileRes = await axios.get(`${API_BASE}/profile/${telegramId}`);
//         const user = profileRes.data;
//         const photos = user.photos || [];

//         let photoButtons = [];
//         if (photos.length > 0) {
//           photoButtons = photos.map((photo, index) => ([
//             { text: `üóëÔ∏è Delete Photo ${index + 1}`, callback_data: `delete_photo_${index}` }
//           ]));
//         }
        
//         photoButtons.push([
//           { text: 'üì∏ Upload New Photo', callback_data: 'upload_photo' },
//           { text: 'üîô Back to Profile', callback_data: 'settings_profile' }
//         ]);

//         const opts = {
//           reply_markup: {
//             inline_keyboard: photoButtons
//           }
//         };

//         bot.sendMessage(chatId, photoMsg, opts);
//       } catch (err) {
//         bot.sendMessage(chatId, '‚ùå Failed to load photo management. Please try again later.');
//       }
      
//     } else if (data === 'upload_photo') {
//       userStates[telegramId] = { uploadingPhoto: true };
//       bot.sendMessage(chatId, 'üì∏ **UPLOAD PHOTO** üì∏\n\nSend me a photo to add to your profile!\n\nüì± Make sure it\'s a clear, high-quality image.\n\n‚ùå Send /cancel to abort.');
      
//     } else if (data.startsWith('delete_photo_')) {
//       const photoIndex = parseInt(data.split('_')[2]);
      
//       try {
//         await axios.delete(`${API_BASE}/profile/${telegramId}/photo/${photoIndex}`);
//         bot.sendMessage(chatId, '‚úÖ Photo deleted successfully!');
        
//         // Refresh photo management
//         setTimeout(() => {
//           // Trigger manage_photos again
//           bot.sendMessage(chatId, 'Photo management updated. Use /settings to manage more photos.');
//         }, 1000);
        
//       } catch (err) {
//         bot.sendMessage(chatId, '‚ùå Failed to delete photo. Please try again later.');
//       }
      
//     } else if (data === 'account_info') {
//       try {
//         const profileRes = await axios.get(`${API_BASE}/profile/${telegramId}`);
//         const user = profileRes.data;
        
//         const joinDate = user.createdAt ? new Date(user.createdAt).toLocaleDateString() : 'Unknown';
//         const lastActive = user.lastActive ? new Date(user.lastActive).toLocaleDateString() : 'Unknown';
        
//         const accountMsg = `üìä **ACCOUNT INFORMATION** üìä\n\n` +
//           `üë§ **Profile Details:**\n` +
//           `‚Ä¢ Name: ${user.name || 'Not set'}\n` +
//           `‚Ä¢ Age: ${user.age || 'Not set'}\n` +
//           `‚Ä¢ Location: ${user.location || 'Not set'}\n` +
//           `‚Ä¢ Member since: ${joinDate}\n` +
//           `‚Ä¢ Last active: ${lastActive}\n\n` +
//           `üìà **Statistics:**\n` +
//           `‚Ä¢ Profile views: ${user.stats?.views || 0}\n` +
//           `‚Ä¢ Likes given: ${user.stats?.likesGiven || 0}\n` +
//           `‚Ä¢ Likes received: ${user.stats?.likesReceived || 0}\n` +
//           `‚Ä¢ Matches: ${user.stats?.matches || 0}\n\n` +
//           `üí∞ **Account Status:**\n` +
//           `‚Ä¢ VIP Status: ${user.isVip ? 'üëë Active' : '‚ùå Not Active'}\n` +
//           `‚Ä¢ Coin Balance: ${user.coinBalance || 0}\n` +
//           `‚Ä¢ Account Status: ${user.isActive ? '‚úÖ Active' : '‚è∏Ô∏è Inactive'}`;

//         const opts = {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 { text: 'üì• Download Data', callback_data: 'download_data' },
//                 { text: 'üîô Back to Account', callback_data: 'settings_account' }
//               ]
//             ]
//           }
//         };

//         bot.sendMessage(chatId, accountMsg, opts);
//       } catch (err) {
//         bot.sendMessage(chatId, '‚ùå Failed to load account information. Please try again later.');
//       }
      
//     } else if (data === 'download_data') {
//       bot.sendMessage(chatId, 'üì• **DATA DOWNLOAD** üì•\n\nYour data download request has been received.\n\nüìß We will send your complete data export to your registered email within 24 hours.\n\nüìã The export will include:\n‚Ä¢ Profile information\n‚Ä¢ Match history\n‚Ä¢ Message history\n‚Ä¢ Account statistics\n‚Ä¢ Settings preferences');
      
//     } else if (data === 'deactivate_account') {
//       const deactivateMsg = `‚è∏Ô∏è **DEACTIVATE ACCOUNT** ‚è∏Ô∏è\n\n` +
//         `‚ö†Ô∏è **This will temporarily hide your profile:**\n` +
//         `‚Ä¢ Your profile won't appear in search\n` +
//         `‚Ä¢ You won't receive new matches\n` +
//         `‚Ä¢ Your data will be preserved\n` +
//         `‚Ä¢ You can reactivate anytime\n\n` +
//         `üîÑ **This is reversible** - you can reactivate later.\n\n` +
//         `Are you sure you want to deactivate your account?`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: '‚è∏Ô∏è Yes, Deactivate', callback_data: 'confirm_deactivate' },
//               { text: '‚ùå Cancel', callback_data: 'settings_account' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, deactivateMsg, opts);
      
//     } else if (data === 'confirm_deactivate') {
//       try {
//         await axios.post(`${API_BASE}/users/deactivate/${telegramId}`);
//         bot.sendMessage(chatId, '‚è∏Ô∏è **Account Deactivated** ‚è∏Ô∏è\n\nYour account has been temporarily deactivated.\n\nüîÑ To reactivate, simply use any bot command or send /start.\n\nüíô We hope to see you back soon!');
//       } catch (err) {
//         bot.sendMessage(chatId, '‚ùå Failed to deactivate account. Please try again later.');
//       }
      
//     } else if (data === 'delete_account') {
//       const deleteMsg = `üóëÔ∏è **DELETE ACCOUNT** üóëÔ∏è\n\n` +
//         `‚ö†Ô∏è **PERMANENT ACTION WARNING:**\n` +
//         `‚Ä¢ All your data will be permanently deleted\n` +
//         `‚Ä¢ Your matches and conversations will be lost\n` +
//         `‚Ä¢ Your photos and profile will be removed\n` +
//         `‚Ä¢ This action CANNOT be undone\n\n` +
//         `üí° **Alternative:** Consider deactivating instead\n\n` +
//         `‚ùì **Need help?** Contact support first\n\n` +
//         `Are you absolutely sure you want to delete your account?`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: '‚è∏Ô∏è Deactivate Instead', callback_data: 'deactivate_account' },
//               { text: 'üìû Contact Support', callback_data: 'contact_support' }
//             ],
//             [
//               { text: 'üóëÔ∏è Yes, Delete Forever', callback_data: 'confirm_delete' },
//               { text: '‚ùå Cancel', callback_data: 'settings_account' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, deleteMsg, opts);
      
//     } else if (data === 'confirm_delete') {
//       const finalWarningMsg = `üö® **FINAL WARNING** üö®\n\n` +
//         `This is your last chance to cancel.\n\n` +
//         `Clicking "DELETE NOW" will:\n` +
//         `‚Ä¢ Permanently delete ALL your data\n` +
//         `‚Ä¢ Remove your profile forever\n` +
//         `‚Ä¢ Delete all matches and messages\n` +
//         `‚Ä¢ This CANNOT be undone\n\n` +
//         `Type "DELETE MY ACCOUNT" to confirm:`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: '‚ùå Cancel - Keep My Account', callback_data: 'settings_account' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, finalWarningMsg, opts);
      
//     } else if (data === 'report_user') {
//       // Set user state for user reporting
//       userStates[telegramId] = { reporting: 'user' };
      
//       const reportUserMsg = `üë§ **REPORT USER** üë§\n\n` +
//         `Help us maintain a safe community by reporting inappropriate behavior.\n\n` +
//         `üìù **To report a user, please provide:**\n` +
//         `‚Ä¢ User's name or username\n` +
//         `‚Ä¢ Description of inappropriate behavior\n` +
//         `‚Ä¢ Screenshots (if available)\n` +
//         `‚Ä¢ When the incident occurred\n\n` +
//         `‚ö†Ô∏è **Report Types:**\n` +
//         `‚Ä¢ Harassment or bullying\n` +
//         `‚Ä¢ Fake profile or catfishing\n` +
//         `‚Ä¢ Inappropriate messages/photos\n` +
//         `‚Ä¢ Spam or scam attempts\n` +
//         `‚Ä¢ Other violations\n\n` +
//         `Send your detailed report as a message now.`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üìû Contact Support Instead', callback_data: 'contact_support' },
//               { text: '‚ùå Cancel', callback_data: 'cancel_report' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, reportUserMsg, opts);
      
//     } else if (data === 'report_content') {
//       // Set user state for content reporting
//       userStates[telegramId] = { reporting: 'content' };
      
//       const reportContentMsg = `üí¨ **REPORT INAPPROPRIATE CONTENT** üí¨\n\n` +
//         `Help us keep Kisu1bot safe by reporting inappropriate content.\n\n` +
//         `üìù **Content to report:**\n` +
//         `‚Ä¢ Inappropriate photos or videos\n` +
//         `‚Ä¢ Offensive messages or stories\n` +
//         `‚Ä¢ Adult content in public areas\n` +
//         `‚Ä¢ Spam or promotional content\n` +
//         `‚Ä¢ Hate speech or discrimination\n\n` +
//         `üìã **Please include:**\n` +
//         `‚Ä¢ Where you saw the content\n` +
//         `‚Ä¢ Description of the issue\n` +
//         `‚Ä¢ Screenshots if possible\n\n` +
//         `Send your content report as a message now.`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üìû Contact Support Instead', callback_data: 'contact_support' },
//               { text: '‚ùå Cancel', callback_data: 'cancel_report' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, reportContentMsg, opts);
      
//     } else if (data === 'cancel_report') {
//       // Clear any reporting state
//       delete userStates[telegramId];
//       bot.sendMessage(chatId, '‚ùå Report cancelled. Thank you for helping keep our community safe!\n\nIf you need help with something else, use /help or /contact.');
      
//     } else if (data === 'report_bug') {
//       // Set user state for bug reporting
//       userStates[telegramId] = { reporting: 'bug' };
//       bot.sendMessage(chatId, 'üêõ **REPORT BUG** üêõ\n\nPlease describe the bug you encountered:\n\nüìù Include:\n‚Ä¢ What you were trying to do\n‚Ä¢ What happened instead\n‚Ä¢ Steps to reproduce\n‚Ä¢ Any error messages\n\nSend your bug report as a message, and we\'ll investigate it promptly!\n\n‚ùå Send /cancel to abort.');
      
//     } else if (data === 'feature_request') {
//       // Set user state for feature request
//       userStates[telegramId] = { reporting: 'feature' };
//       bot.sendMessage(chatId, 'üí° **FEATURE REQUEST** üí°\n\nWe love hearing your ideas!\n\nüìù Please describe:\n‚Ä¢ The feature you\'d like to see\n‚Ä¢ How it would help you\n‚Ä¢ Any specific details or examples\n\nSend your feature request as a message!\n\n‚ùå Send /cancel to abort.');
      
//     } else if (data === 'help_guide') {
//       const guideMsg = `üìö **USER GUIDE** üìö\n\n` +
//         `Learn how to use Kisu1bot effectively:\n\n` +
//         `üöÄ **Getting Started:**\n` +
//         `1. Complete your profile with /register\n` +
//         `2. Add photos with /photo\n` +
//         `3. Set preferences with /settings\n` +
//         `4. Start browsing with /browse\n\n` +
//         `üí´ **Key Features:**\n` +
//         `‚Ä¢ Browse profiles and like/pass\n` +
//         `‚Ä¢ Send gifts to show interest\n` +
//         `‚Ä¢ Use coins for premium features\n` +
//         `‚Ä¢ Get VIP for unlimited swipes\n\n` +
//         `üéØ **Pro Tips:**\n` +
//         `‚Ä¢ Complete your profile for better matches\n` +
//         `‚Ä¢ Be authentic in your bio\n` +
//         `‚Ä¢ Use high-quality photos\n` +
//         `‚Ä¢ Stay active for better visibility`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: '‚ùì FAQ', callback_data: 'help_faq' },
//               { text: 'üîô Back', callback_data: 'settings_help' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, guideMsg, opts);
      
//     } else if (data === 'help_faq') {
//       const faqMsg = `‚ùì **FREQUENTLY ASKED QUESTIONS** ‚ùì\n\n` +
//         `**Q: How do I get more matches?**\n` +
//         `A: Complete your profile, add quality photos, and stay active!\n\n` +
//         `**Q: What are coins used for?**\n` +
//         `A: Coins unlock premium features like gifts, boosts, and VIP.\n\n` +
//         `**Q: How does VIP work?**\n` +
//         `A: VIP gives unlimited swipes, priority matching, and special features.\n\n` +
//         `**Q: Can I change my location?**\n` +
//         `A: Yes! Use /settings ‚Üí Profile Settings ‚Üí Edit Location.\n\n` +
//         `**Q: How do I report inappropriate behavior?**\n` +
//         `A: Use /report or contact support immediately.\n\n` +
//         `**Q: Can I delete my account?**\n` +
//         `A: Yes, but consider deactivating first. Go to Settings ‚Üí Account.`;

//       const opts = {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               { text: 'üìö User Guide', callback_data: 'help_guide' },
//               { text: 'üîô Back', callback_data: 'settings_help' }
//             ]
//           ]
//         }
//       };

//       bot.sendMessage(chatId, faqMsg, opts);
      
//     } else if (data === 'show_help') {
//       // Redirect to main help command
//       const helpMsg = `ü§ñ **KISU1BOT HELP GUIDE** ü§ñ\n\n` +
//         `üìã **Main Commands:**\n` +
//         `‚Ä¢ /start - Welcome message\n` +
//         `‚Ä¢ /register - Create your dating profile\n` +
//         `‚Ä¢ /browse - Browse and like profiles\n` +
//         `‚Ä¢ /profile - View/edit your profile\n` +
//         `‚Ä¢ /settings - Access all settings\n\n` +
//         `üí¨ **Social Features:**\n` +
//         `‚Ä¢ /stories - Post and view stories\n` +
//         `‚Ä¢ /gifts - Send gifts to matches\n` +
//         `‚Ä¢ /matches - View your matches\n\n` +
//         `üíé **Premium Features:**\n` +
//         `‚Ä¢ /coins - Buy coins for premium features\n` +
//         `‚Ä¢ /vip - Get VIP membership benefits\n\n` +
//         `üõ†Ô∏è **Support Commands:**\n` +
//         `‚Ä¢ /help - Show this help guide\n` +
//         `‚Ä¢ /report - Report users or issues\n` +
//         `‚Ä¢ /contact - Contact support team\n` +
//         `‚Ä¢ /delete - Delete your profile\n\n` +
//         `üí° **Tips:**\n` +
//         `‚Ä¢ Complete your profile for better matches\n` +
//         `‚Ä¢ Be respectful and genuine\n` +
//         `‚Ä¢ Use stories to show your personality\n` +
//         `‚Ä¢ VIP membership unlocks premium features`;

//       const buttons = [
//         [
//           { text: 'üë§ My Profile', callback_data: 'view_profile' },
//           { text: 'üîç Browse Profiles', callback_data: 'browse_profiles' }
//         ],
//         [
//           { text: '‚öôÔ∏è Settings', callback_data: 'main_settings' },
//           { text: 'üíé Get VIP', callback_data: 'manage_vip' }
//         ],
//         [
//           { text: 'üìû Contact Support', callback_data: 'contact_support' }
//         ]
//       ];

//       bot.sendMessage(chatId, helpMsg, {
//         reply_markup: {
//           inline_keyboard: buttons
//         }
//       });
//     }

//     // Answer the callback query to remove loading state
//     try {
//       bot.answerCallbackQuery(callbackQuery.id);
//     } catch (answerErr) {
//       console.error('Failed to answer callback query:', answerErr.message);
//     }

//   } catch (err) {
//     console.error('Callback query error:', err);
//     try {
//       bot.answerCallbackQuery(callbackQuery.id, { text: 'Error occurred. Please try again.' });
//     } catch (answerErr) {
//       console.error('Failed to answer callback query with error:', answerErr.message);
//     }
//   }
// });

// // In production (detect by Render's PORT or explicit NODE_ENV), use webhook mode without spawning API server here
// if (isProduction) {
//   console.log('Production mode: Using webhook...');
//   // Only start the Express server for webhook; server.js should be started separately (e.g., by start.js or hosting platform)

//   // Handle process termination gracefully
//   process.on('SIGTERM', () => {
//     console.log('Received SIGTERM, shutting down gracefully...');
//     process.exit();
//   });
// } else {
//   // Development mode: start Express server for local testing
// }